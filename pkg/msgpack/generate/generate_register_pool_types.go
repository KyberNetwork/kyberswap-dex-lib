package main

import (
	"bufio"
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	structNameByFileName = map[string]string{
		"pool_simulator.go": "PoolSimulator",
		"hook.go":           "Hook",
	}
)

func main() {
	var paths []string
	var structNames map[string]string

	dir := findGoModDirInParents()
	if dir != "" {
		paths, structNames = findAllSourceFiles(dir)
	}
	if len(paths) == 0 {
		return
	}

	moduleName := "github.com/KyberNetwork/" + filepath.Base(dir)
	pkgNames := getPackageNamesFromSourceFiles(paths, dir)
	importPaths := getPackageImportPathsFromSourceFiles(paths, dir, moduleName)

	outFile, err := os.Create("./register_pool_types.gen.go")
	if err != nil {
		log.Fatalf("could not create dispatch_gen.go: %s", err)
	}
	defer func(outFile *os.File) {
		_ = outFile.Close()
	}(outFile)

	outFileBuf := bufio.NewWriter(outFile)
	defer func(outFileBuf *bufio.Writer) {
		_ = outFileBuf.Flush()
	}(outFileBuf)

	emitImports(outFileBuf, moduleName, pkgNames, importPaths)
	emitf(outFileBuf, "\n")

	emitf(outFileBuf, "func init() {\n")
	for i, path := range paths {
		structName := structNames[path]
		pkgName := pkgNames[i]
		emitf(outFileBuf, "\tmsgpack.RegisterConcreteType(&%s.%s{})\n", pkgName, structName)
	}
	emitf(outFileBuf, "}\n")
}

func emitImports(outFileBuf io.Writer, dir string, pkgNames, importPaths []string) {
	emitf(outFileBuf, "package msgpack\n")
	emitf(outFileBuf, "\n")

	emitf(outFileBuf, "// Code generated by %s/pkg/msgpack/generate DO NOT EDIT.\n", dir)
	emitf(outFileBuf, "//go:generate go run ./generate\n")
	emitf(outFileBuf, "\n")

	emitf(outFileBuf, "import (\n")
	emitf(outFileBuf, "\t\"github.com/KyberNetwork/msgpack/v5\"\n")
	emitf(outFileBuf, "\n")
	for i, dexName := range pkgNames {
		emitf(outFileBuf, "\t%s \"%s\"\n", dexName, importPaths[i])
	}
	emitf(outFileBuf, ")\n")
}

func emitf(w io.Writer, format string, a ...any) {
	_, _ = fmt.Fprintf(w, format, a...)
}

func findGoModDirInParents() string {
	var (
		hasGoMod = false
		cwd, _   = os.Getwd()
		visited  = make(map[string]struct{}) // to eliminate cycle
	)
	for {
		if _, ok := visited[cwd]; ok {
			break
		}
		visited[cwd] = struct{}{}
		entries, err := os.ReadDir(cwd)
		if err != nil {
			break
		}
		for _, entry := range entries {
			if entry.Name() == "go.mod" {
				hasGoMod = true
				break
			}
		}
		if hasGoMod {
			break
		}
		cwd = filepath.Join(cwd, "..")
		cwd, err = filepath.Abs(cwd)
		if err != nil {
			break
		}
	}
	if hasGoMod {
		return cwd
	}
	return ""
}

func findAllSourceFiles(rootDir string) (paths []string, structNames map[string]string) {
	structNames = make(map[string]string)
	regexps := make(map[string]*regexp.Regexp, len(structNameByFileName))
	if err := filepath.Walk(rootDir, func(path string, info fs.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return err
		}
		structName := structNameByFileName[info.Name()]
		if structName == "" {
			return nil
		}
		structRegexp := regexps[structName]
		if structRegexp == nil {
			regexps[structName] = regexp.MustCompile("(\ntype +|\\t)" + structName + " +struct")
			structRegexp = regexps[structName]
		}
		b, err := os.ReadFile(path)
		if err != nil || !structRegexp.Match(b) {
			return err
		}
		paths = append(paths, path)
		structNames[path] = structName
		return nil
	}); err != nil {
		panic(err)
	}
	return paths, structNames
}

func getPackageNamesFromSourceFiles(sourcePaths []string, dir string) []string {
	importNames := make([]string, len(sourcePaths))
	for i, path := range sourcePaths {
		relPath, _ := filepath.Rel(dir, path)
		dexName := filepath.Dir(relPath)
		dexName = strings.ReplaceAll(dexName, "-", "")
		dexName = strings.ReplaceAll(dexName, "/", "_")
		importNames[i] = dexName
	}
	return importNames
}

func getPackageImportPathsFromSourceFiles(sourcePaths []string, dir, moduleName string) []string {
	paths := make([]string, len(sourcePaths))
	for i, path := range sourcePaths {
		relPath, _ := filepath.Rel(dir, path)
		importPath := filepath.Join(moduleName, filepath.Dir(relPath))
		paths[i] = importPath
	}
	return paths
}

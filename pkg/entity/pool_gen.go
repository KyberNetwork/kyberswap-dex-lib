package entity

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Pool) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 13 {
		err = msgp.ArrayError{Wanted: 13, Got: zb0001}
		return
	}
	z.Address, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	z.ReserveUsd, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "ReserveUsd")
		return
	}
	z.AmplifiedTvl, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "AmplifiedTvl")
		return
	}
	z.SwapFee, err = dc.ReadFloat64()
	if err != nil {
		err = msgp.WrapError(err, "SwapFee")
		return
	}
	z.Exchange, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Exchange")
		return
	}
	z.Type, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	z.Timestamp, err = dc.ReadInt64()
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "Reserves")
		return
	}
	if cap(z.Reserves) >= int(zb0002) {
		z.Reserves = (z.Reserves)[:zb0002]
	} else {
		z.Reserves = make(PoolReserves, zb0002)
	}
	for za0001 := range z.Reserves {
		z.Reserves[za0001], err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "Reserves", za0001)
			return
		}
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "Tokens")
		return
	}
	if cap(z.Tokens) >= int(zb0003) {
		z.Tokens = (z.Tokens)[:zb0003]
	} else {
		z.Tokens = make([]*PoolToken, zb0003)
	}
	for za0002 := range z.Tokens {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "Tokens", za0002)
				return
			}
			z.Tokens[za0002] = nil
		} else {
			if z.Tokens[za0002] == nil {
				z.Tokens[za0002] = new(PoolToken)
			}
			err = z.Tokens[za0002].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Tokens", za0002)
				return
			}
		}
	}
	z.Extra, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Extra")
		return
	}
	z.StaticExtra, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "StaticExtra")
		return
	}
	z.TotalSupply, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "TotalSupply")
		return
	}
	z.BlockNumber, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "BlockNumber")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Pool) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 13
	err = en.Append(0x9d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	err = en.WriteFloat64(z.ReserveUsd)
	if err != nil {
		err = msgp.WrapError(err, "ReserveUsd")
		return
	}
	err = en.WriteFloat64(z.AmplifiedTvl)
	if err != nil {
		err = msgp.WrapError(err, "AmplifiedTvl")
		return
	}
	err = en.WriteFloat64(z.SwapFee)
	if err != nil {
		err = msgp.WrapError(err, "SwapFee")
		return
	}
	err = en.WriteString(z.Exchange)
	if err != nil {
		err = msgp.WrapError(err, "Exchange")
		return
	}
	err = en.WriteString(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	err = en.WriteInt64(z.Timestamp)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Reserves)))
	if err != nil {
		err = msgp.WrapError(err, "Reserves")
		return
	}
	for za0001 := range z.Reserves {
		err = en.WriteString(z.Reserves[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Reserves", za0001)
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Tokens)))
	if err != nil {
		err = msgp.WrapError(err, "Tokens")
		return
	}
	for za0002 := range z.Tokens {
		if z.Tokens[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Tokens[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Tokens", za0002)
				return
			}
		}
	}
	err = en.WriteString(z.Extra)
	if err != nil {
		err = msgp.WrapError(err, "Extra")
		return
	}
	err = en.WriteString(z.StaticExtra)
	if err != nil {
		err = msgp.WrapError(err, "StaticExtra")
		return
	}
	err = en.WriteString(z.TotalSupply)
	if err != nil {
		err = msgp.WrapError(err, "TotalSupply")
		return
	}
	err = en.WriteUint64(z.BlockNumber)
	if err != nil {
		err = msgp.WrapError(err, "BlockNumber")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Pool) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 13
	o = append(o, 0x9d)
	o = msgp.AppendString(o, z.Address)
	o = msgp.AppendFloat64(o, z.ReserveUsd)
	o = msgp.AppendFloat64(o, z.AmplifiedTvl)
	o = msgp.AppendFloat64(o, z.SwapFee)
	o = msgp.AppendString(o, z.Exchange)
	o = msgp.AppendString(o, z.Type)
	o = msgp.AppendInt64(o, z.Timestamp)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Reserves)))
	for za0001 := range z.Reserves {
		o = msgp.AppendString(o, z.Reserves[za0001])
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Tokens)))
	for za0002 := range z.Tokens {
		if z.Tokens[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Tokens[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Tokens", za0002)
				return
			}
		}
	}
	o = msgp.AppendString(o, z.Extra)
	o = msgp.AppendString(o, z.StaticExtra)
	o = msgp.AppendString(o, z.TotalSupply)
	o = msgp.AppendUint64(o, z.BlockNumber)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Pool) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 13 {
		err = msgp.ArrayError{Wanted: 13, Got: zb0001}
		return
	}
	z.Address, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	z.ReserveUsd, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "ReserveUsd")
		return
	}
	z.AmplifiedTvl, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AmplifiedTvl")
		return
	}
	z.SwapFee, bts, err = msgp.ReadFloat64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "SwapFee")
		return
	}
	z.Exchange, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Exchange")
		return
	}
	z.Type, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	z.Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Reserves")
		return
	}
	if cap(z.Reserves) >= int(zb0002) {
		z.Reserves = (z.Reserves)[:zb0002]
	} else {
		z.Reserves = make(PoolReserves, zb0002)
	}
	for za0001 := range z.Reserves {
		z.Reserves[za0001], bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "Reserves", za0001)
			return
		}
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Tokens")
		return
	}
	if cap(z.Tokens) >= int(zb0003) {
		z.Tokens = (z.Tokens)[:zb0003]
	} else {
		z.Tokens = make([]*PoolToken, zb0003)
	}
	for za0002 := range z.Tokens {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			z.Tokens[za0002] = nil
		} else {
			if z.Tokens[za0002] == nil {
				z.Tokens[za0002] = new(PoolToken)
			}
			bts, err = z.Tokens[za0002].UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tokens", za0002)
				return
			}
		}
	}
	z.Extra, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Extra")
		return
	}
	z.StaticExtra, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "StaticExtra")
		return
	}
	z.TotalSupply, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "TotalSupply")
		return
	}
	z.BlockNumber, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BlockNumber")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Pool) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Address) + msgp.Float64Size + msgp.Float64Size + msgp.Float64Size + msgp.StringPrefixSize + len(z.Exchange) + msgp.StringPrefixSize + len(z.Type) + msgp.Int64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Reserves {
		s += msgp.StringPrefixSize + len(z.Reserves[za0001])
	}
	s += msgp.ArrayHeaderSize
	for za0002 := range z.Tokens {
		if z.Tokens[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Tokens[za0002].Msgsize()
		}
	}
	s += msgp.StringPrefixSize + len(z.Extra) + msgp.StringPrefixSize + len(z.StaticExtra) + msgp.StringPrefixSize + len(z.TotalSupply) + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PoolReserves) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(PoolReserves, zb0002)
	}
	for zb0001 := range *z {
		(*z)[zb0001], err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PoolReserves) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		err = en.WriteString(z[zb0003])
		if err != nil {
			err = msgp.WrapError(err, zb0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PoolReserves) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0003 := range z {
		o = msgp.AppendString(o, z[zb0003])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PoolReserves) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(PoolReserves, zb0002)
	}
	for zb0001 := range *z {
		(*z)[zb0001], bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PoolReserves) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		s += msgp.StringPrefixSize + len(z[zb0003])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PoolToken) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zb0001}
		return
	}
	z.Address, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	z.Name, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	z.Symbol, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Symbol")
		return
	}
	z.Decimals, err = dc.ReadUint8()
	if err != nil {
		err = msgp.WrapError(err, "Decimals")
		return
	}
	z.Weight, err = dc.ReadUint()
	if err != nil {
		err = msgp.WrapError(err, "Weight")
		return
	}
	z.Swappable, err = dc.ReadBool()
	if err != nil {
		err = msgp.WrapError(err, "Swappable")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PoolToken) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return
	}
	err = en.WriteString(z.Address)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	err = en.WriteString(z.Symbol)
	if err != nil {
		err = msgp.WrapError(err, "Symbol")
		return
	}
	err = en.WriteUint8(z.Decimals)
	if err != nil {
		err = msgp.WrapError(err, "Decimals")
		return
	}
	err = en.WriteUint(z.Weight)
	if err != nil {
		err = msgp.WrapError(err, "Weight")
		return
	}
	err = en.WriteBool(z.Swappable)
	if err != nil {
		err = msgp.WrapError(err, "Swappable")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PoolToken) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendString(o, z.Address)
	o = msgp.AppendString(o, z.Name)
	o = msgp.AppendString(o, z.Symbol)
	o = msgp.AppendUint8(o, z.Decimals)
	o = msgp.AppendUint(o, z.Weight)
	o = msgp.AppendBool(o, z.Swappable)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PoolToken) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zb0001}
		return
	}
	z.Address, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	z.Name, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	z.Symbol, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Symbol")
		return
	}
	z.Decimals, bts, err = msgp.ReadUint8Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Decimals")
		return
	}
	z.Weight, bts, err = msgp.ReadUintBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Weight")
		return
	}
	z.Swappable, bts, err = msgp.ReadBoolBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Swappable")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PoolToken) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Address) + msgp.StringPrefixSize + len(z.Name) + msgp.StringPrefixSize + len(z.Symbol) + msgp.Uint8Size + msgp.UintSize + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PoolTokens) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(PoolTokens, zb0002)
	}
	for zb0001 := range *z {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(PoolToken)
			}
			err = (*z)[zb0001].DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PoolTokens) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0003 := range z {
		if z[zb0003] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z[zb0003].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, zb0003)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PoolTokens) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zb0003 := range z {
		if z[zb0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z[zb0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, zb0003)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PoolTokens) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(PoolTokens, zb0002)
	}
	for zb0001 := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(PoolToken)
			}
			bts, err = (*z)[zb0001].UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PoolTokens) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		if z[zb0003] == nil {
			s += msgp.NilSize
		} else {
			s += z[zb0003].Msgsize()
		}
	}
	return
}

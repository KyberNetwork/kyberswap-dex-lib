package ezeth

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"math/big"

	"github.com/KyberNetwork/kyberswap-dex-lib/pkg/msgpencode"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *PoolSimulator) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 13 {
		err = msgp.ArrayError{Wanted: 13, Got: zb0001}
		return
	}
	err = z.Pool.DecodeMsg(dc)
	if err != nil {
		err = msgp.WrapError(err, "Pool")
		return
	}
	z.paused, err = dc.ReadBool()
	if err != nil {
		err = msgp.WrapError(err, "paused")
		return
	}
	z.strategyManagerPaused, err = dc.ReadBool()
	if err != nil {
		err = msgp.WrapError(err, "strategyManagerPaused")
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "collateralTokenIndex")
		return
	}
	if z.collateralTokenIndex == nil {
		z.collateralTokenIndex = make(map[string]int, zb0002)
	} else if len(z.collateralTokenIndex) > 0 {
		for key := range z.collateralTokenIndex {
			delete(z.collateralTokenIndex, key)
		}
	}
	for zb0002 > 0 {
		zb0002--
		var za0001 string
		var za0002 int
		za0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenIndex")
			return
		}
		za0002, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenIndex", za0001)
			return
		}
		z.collateralTokenIndex[za0001] = za0002
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorTokenTVLs")
		return
	}
	if cap(z.operatorDelegatorTokenTVLs) >= int(zb0003) {
		z.operatorDelegatorTokenTVLs = (z.operatorDelegatorTokenTVLs)[:zb0003]
	} else {
		z.operatorDelegatorTokenTVLs = make([][]*big.Int, zb0003)
	}
	for za0003 := range z.operatorDelegatorTokenTVLs {
		var zb0004 uint32
		zb0004, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003)
			return
		}
		if cap(z.operatorDelegatorTokenTVLs[za0003]) >= int(zb0004) {
			z.operatorDelegatorTokenTVLs[za0003] = (z.operatorDelegatorTokenTVLs[za0003])[:zb0004]
		} else {
			z.operatorDelegatorTokenTVLs[za0003] = make([]*big.Int, zb0004)
		}
		for za0004 := range z.operatorDelegatorTokenTVLs[za0003] {
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003, za0004)
					return
				}
				z.operatorDelegatorTokenTVLs[za0003][za0004] = nil
			} else {
				{
					var zb0005 []byte
					zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.operatorDelegatorTokenTVLs[za0003][za0004]))
					if err != nil {
						err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003, za0004)
						return
					}
					z.operatorDelegatorTokenTVLs[za0003][za0004] = msgpencode.DecodeInt(zb0005)
				}
			}
		}
	}
	var zb0006 uint32
	zb0006, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorTVLs")
		return
	}
	if cap(z.operatorDelegatorTVLs) >= int(zb0006) {
		z.operatorDelegatorTVLs = (z.operatorDelegatorTVLs)[:zb0006]
	} else {
		z.operatorDelegatorTVLs = make([]*big.Int, zb0006)
	}
	for za0005 := range z.operatorDelegatorTVLs {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "operatorDelegatorTVLs", za0005)
				return
			}
			z.operatorDelegatorTVLs[za0005] = nil
		} else {
			{
				var zb0007 []byte
				zb0007, err = dc.ReadBytes(msgpencode.EncodeInt(z.operatorDelegatorTVLs[za0005]))
				if err != nil {
					err = msgp.WrapError(err, "operatorDelegatorTVLs", za0005)
					return
				}
				z.operatorDelegatorTVLs[za0005] = msgpencode.DecodeInt(zb0007)
			}
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "totalTVL")
			return
		}
		z.totalTVL = nil
	} else {
		{
			var zb0008 []byte
			zb0008, err = dc.ReadBytes(msgpencode.EncodeInt(z.totalTVL))
			if err != nil {
				err = msgp.WrapError(err, "totalTVL")
				return
			}
			z.totalTVL = msgpencode.DecodeInt(zb0008)
		}
	}
	var zb0009 uint32
	zb0009, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorAllocations")
		return
	}
	if cap(z.operatorDelegatorAllocations) >= int(zb0009) {
		z.operatorDelegatorAllocations = (z.operatorDelegatorAllocations)[:zb0009]
	} else {
		z.operatorDelegatorAllocations = make([]*big.Int, zb0009)
	}
	for za0006 := range z.operatorDelegatorAllocations {
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "operatorDelegatorAllocations", za0006)
				return
			}
			z.operatorDelegatorAllocations[za0006] = nil
		} else {
			{
				var zb0010 []byte
				zb0010, err = dc.ReadBytes(msgpencode.EncodeInt(z.operatorDelegatorAllocations[za0006]))
				if err != nil {
					err = msgp.WrapError(err, "operatorDelegatorAllocations", za0006)
					return
				}
				z.operatorDelegatorAllocations[za0006] = msgpencode.DecodeInt(zb0010)
			}
		}
	}
	var zb0011 uint32
	zb0011, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "tokenStrategyMapping")
		return
	}
	if cap(z.tokenStrategyMapping) >= int(zb0011) {
		z.tokenStrategyMapping = (z.tokenStrategyMapping)[:zb0011]
	} else {
		z.tokenStrategyMapping = make([]map[string]bool, zb0011)
	}
	for za0007 := range z.tokenStrategyMapping {
		var zb0012 uint32
		zb0012, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, "tokenStrategyMapping", za0007)
			return
		}
		if z.tokenStrategyMapping[za0007] == nil {
			z.tokenStrategyMapping[za0007] = make(map[string]bool, zb0012)
		} else if len(z.tokenStrategyMapping[za0007]) > 0 {
			for key := range z.tokenStrategyMapping[za0007] {
				delete(z.tokenStrategyMapping[za0007], key)
			}
		}
		for zb0012 > 0 {
			zb0012--
			var za0008 string
			var za0009 bool
			za0008, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "tokenStrategyMapping", za0007)
				return
			}
			za0009, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "tokenStrategyMapping", za0007, za0008)
				return
			}
			z.tokenStrategyMapping[za0007][za0008] = za0009
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "totalSupply")
			return
		}
		z.totalSupply = nil
	} else {
		{
			var zb0013 []byte
			zb0013, err = dc.ReadBytes(msgpencode.EncodeInt(z.totalSupply))
			if err != nil {
				err = msgp.WrapError(err, "totalSupply")
				return
			}
			z.totalSupply = msgpencode.DecodeInt(zb0013)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "maxDepositTVL")
			return
		}
		z.maxDepositTVL = nil
	} else {
		{
			var zb0014 []byte
			zb0014, err = dc.ReadBytes(msgpencode.EncodeInt(z.maxDepositTVL))
			if err != nil {
				err = msgp.WrapError(err, "maxDepositTVL")
				return
			}
			z.maxDepositTVL = msgpencode.DecodeInt(zb0014)
		}
	}
	var zb0015 uint32
	zb0015, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "tokenOracleLookup")
		return
	}
	if z.tokenOracleLookup == nil {
		z.tokenOracleLookup = make(map[string]Oracle, zb0015)
	} else if len(z.tokenOracleLookup) > 0 {
		for key := range z.tokenOracleLookup {
			delete(z.tokenOracleLookup, key)
		}
	}
	for zb0015 > 0 {
		zb0015--
		var za0010 string
		var za0011 Oracle
		za0010, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup")
			return
		}
		err = za0011.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup", za0010)
			return
		}
		z.tokenOracleLookup[za0010] = za0011
	}
	var zb0016 uint32
	zb0016, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "collateralTokenTvlLimits")
		return
	}
	if z.collateralTokenTvlLimits == nil {
		z.collateralTokenTvlLimits = make(map[string]*big.Int, zb0016)
	} else if len(z.collateralTokenTvlLimits) > 0 {
		for key := range z.collateralTokenTvlLimits {
			delete(z.collateralTokenTvlLimits, key)
		}
	}
	for zb0016 > 0 {
		zb0016--
		var za0012 string
		var za0013 *big.Int
		za0012, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenTvlLimits")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "collateralTokenTvlLimits", za0012)
				return
			}
			za0013 = nil
		} else {
			{
				var zb0017 []byte
				zb0017, err = dc.ReadBytes(msgpencode.EncodeInt(za0013))
				if err != nil {
					err = msgp.WrapError(err, "collateralTokenTvlLimits", za0012)
					return
				}
				za0013 = msgpencode.DecodeInt(zb0017)
			}
		}
		z.collateralTokenTvlLimits[za0012] = za0013
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PoolSimulator) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 13
	err = en.Append(0x9d)
	if err != nil {
		return
	}
	err = z.Pool.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Pool")
		return
	}
	err = en.WriteBool(z.paused)
	if err != nil {
		err = msgp.WrapError(err, "paused")
		return
	}
	err = en.WriteBool(z.strategyManagerPaused)
	if err != nil {
		err = msgp.WrapError(err, "strategyManagerPaused")
		return
	}
	err = en.WriteMapHeader(uint32(len(z.collateralTokenIndex)))
	if err != nil {
		err = msgp.WrapError(err, "collateralTokenIndex")
		return
	}
	for za0001, za0002 := range z.collateralTokenIndex {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenIndex")
			return
		}
		err = en.WriteInt(za0002)
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenIndex", za0001)
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.operatorDelegatorTokenTVLs)))
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorTokenTVLs")
		return
	}
	for za0003 := range z.operatorDelegatorTokenTVLs {
		err = en.WriteArrayHeader(uint32(len(z.operatorDelegatorTokenTVLs[za0003])))
		if err != nil {
			err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003)
			return
		}
		for za0004 := range z.operatorDelegatorTokenTVLs[za0003] {
			if z.operatorDelegatorTokenTVLs[za0003][za0004] == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteBytes(msgpencode.EncodeInt(z.operatorDelegatorTokenTVLs[za0003][za0004]))
				if err != nil {
					err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003, za0004)
					return
				}
			}
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.operatorDelegatorTVLs)))
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorTVLs")
		return
	}
	for za0005 := range z.operatorDelegatorTVLs {
		if z.operatorDelegatorTVLs[za0005] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(z.operatorDelegatorTVLs[za0005]))
			if err != nil {
				err = msgp.WrapError(err, "operatorDelegatorTVLs", za0005)
				return
			}
		}
	}
	if z.totalTVL == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.totalTVL))
		if err != nil {
			err = msgp.WrapError(err, "totalTVL")
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.operatorDelegatorAllocations)))
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorAllocations")
		return
	}
	for za0006 := range z.operatorDelegatorAllocations {
		if z.operatorDelegatorAllocations[za0006] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(z.operatorDelegatorAllocations[za0006]))
			if err != nil {
				err = msgp.WrapError(err, "operatorDelegatorAllocations", za0006)
				return
			}
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.tokenStrategyMapping)))
	if err != nil {
		err = msgp.WrapError(err, "tokenStrategyMapping")
		return
	}
	for za0007 := range z.tokenStrategyMapping {
		err = en.WriteMapHeader(uint32(len(z.tokenStrategyMapping[za0007])))
		if err != nil {
			err = msgp.WrapError(err, "tokenStrategyMapping", za0007)
			return
		}
		for za0008, za0009 := range z.tokenStrategyMapping[za0007] {
			err = en.WriteString(za0008)
			if err != nil {
				err = msgp.WrapError(err, "tokenStrategyMapping", za0007)
				return
			}
			err = en.WriteBool(za0009)
			if err != nil {
				err = msgp.WrapError(err, "tokenStrategyMapping", za0007, za0008)
				return
			}
		}
	}
	if z.totalSupply == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.totalSupply))
		if err != nil {
			err = msgp.WrapError(err, "totalSupply")
			return
		}
	}
	if z.maxDepositTVL == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.maxDepositTVL))
		if err != nil {
			err = msgp.WrapError(err, "maxDepositTVL")
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.tokenOracleLookup)))
	if err != nil {
		err = msgp.WrapError(err, "tokenOracleLookup")
		return
	}
	for za0010, za0011 := range z.tokenOracleLookup {
		err = en.WriteString(za0010)
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup")
			return
		}
		err = za0011.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup", za0010)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.collateralTokenTvlLimits)))
	if err != nil {
		err = msgp.WrapError(err, "collateralTokenTvlLimits")
		return
	}
	for za0012, za0013 := range z.collateralTokenTvlLimits {
		err = en.WriteString(za0012)
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenTvlLimits")
			return
		}
		if za0013 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0013))
			if err != nil {
				err = msgp.WrapError(err, "collateralTokenTvlLimits", za0012)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PoolSimulator) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 13
	o = append(o, 0x9d)
	o, err = z.Pool.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Pool")
		return
	}
	o = msgp.AppendBool(o, z.paused)
	o = msgp.AppendBool(o, z.strategyManagerPaused)
	o = msgp.AppendMapHeader(o, uint32(len(z.collateralTokenIndex)))
	for za0001, za0002 := range z.collateralTokenIndex {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendInt(o, za0002)
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.operatorDelegatorTokenTVLs)))
	for za0003 := range z.operatorDelegatorTokenTVLs {
		o = msgp.AppendArrayHeader(o, uint32(len(z.operatorDelegatorTokenTVLs[za0003])))
		for za0004 := range z.operatorDelegatorTokenTVLs[za0003] {
			if z.operatorDelegatorTokenTVLs[za0003][za0004] == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.operatorDelegatorTokenTVLs[za0003][za0004]))
			}
		}
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.operatorDelegatorTVLs)))
	for za0005 := range z.operatorDelegatorTVLs {
		if z.operatorDelegatorTVLs[za0005] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.operatorDelegatorTVLs[za0005]))
		}
	}
	if z.totalTVL == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.totalTVL))
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.operatorDelegatorAllocations)))
	for za0006 := range z.operatorDelegatorAllocations {
		if z.operatorDelegatorAllocations[za0006] == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.operatorDelegatorAllocations[za0006]))
		}
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.tokenStrategyMapping)))
	for za0007 := range z.tokenStrategyMapping {
		o = msgp.AppendMapHeader(o, uint32(len(z.tokenStrategyMapping[za0007])))
		for za0008, za0009 := range z.tokenStrategyMapping[za0007] {
			o = msgp.AppendString(o, za0008)
			o = msgp.AppendBool(o, za0009)
		}
	}
	if z.totalSupply == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.totalSupply))
	}
	if z.maxDepositTVL == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.maxDepositTVL))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.tokenOracleLookup)))
	for za0010, za0011 := range z.tokenOracleLookup {
		o = msgp.AppendString(o, za0010)
		o, err = za0011.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup", za0010)
			return
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.collateralTokenTvlLimits)))
	for za0012, za0013 := range z.collateralTokenTvlLimits {
		o = msgp.AppendString(o, za0012)
		if za0013 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0013))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PoolSimulator) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 13 {
		err = msgp.ArrayError{Wanted: 13, Got: zb0001}
		return
	}
	bts, err = z.Pool.UnmarshalMsg(bts)
	if err != nil {
		err = msgp.WrapError(err, "Pool")
		return
	}
	z.paused, bts, err = msgp.ReadBoolBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "paused")
		return
	}
	z.strategyManagerPaused, bts, err = msgp.ReadBoolBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "strategyManagerPaused")
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "collateralTokenIndex")
		return
	}
	if z.collateralTokenIndex == nil {
		z.collateralTokenIndex = make(map[string]int, zb0002)
	} else if len(z.collateralTokenIndex) > 0 {
		for key := range z.collateralTokenIndex {
			delete(z.collateralTokenIndex, key)
		}
	}
	for zb0002 > 0 {
		var za0001 string
		var za0002 int
		zb0002--
		za0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenIndex")
			return
		}
		za0002, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenIndex", za0001)
			return
		}
		z.collateralTokenIndex[za0001] = za0002
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorTokenTVLs")
		return
	}
	if cap(z.operatorDelegatorTokenTVLs) >= int(zb0003) {
		z.operatorDelegatorTokenTVLs = (z.operatorDelegatorTokenTVLs)[:zb0003]
	} else {
		z.operatorDelegatorTokenTVLs = make([][]*big.Int, zb0003)
	}
	for za0003 := range z.operatorDelegatorTokenTVLs {
		var zb0004 uint32
		zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003)
			return
		}
		if cap(z.operatorDelegatorTokenTVLs[za0003]) >= int(zb0004) {
			z.operatorDelegatorTokenTVLs[za0003] = (z.operatorDelegatorTokenTVLs[za0003])[:zb0004]
		} else {
			z.operatorDelegatorTokenTVLs[za0003] = make([]*big.Int, zb0004)
		}
		for za0004 := range z.operatorDelegatorTokenTVLs[za0003] {
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.operatorDelegatorTokenTVLs[za0003][za0004] = nil
			} else {
				{
					var zb0005 []byte
					zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.operatorDelegatorTokenTVLs[za0003][za0004]))
					if err != nil {
						err = msgp.WrapError(err, "operatorDelegatorTokenTVLs", za0003, za0004)
						return
					}
					z.operatorDelegatorTokenTVLs[za0003][za0004] = msgpencode.DecodeInt(zb0005)
				}
			}
		}
	}
	var zb0006 uint32
	zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorTVLs")
		return
	}
	if cap(z.operatorDelegatorTVLs) >= int(zb0006) {
		z.operatorDelegatorTVLs = (z.operatorDelegatorTVLs)[:zb0006]
	} else {
		z.operatorDelegatorTVLs = make([]*big.Int, zb0006)
	}
	for za0005 := range z.operatorDelegatorTVLs {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			z.operatorDelegatorTVLs[za0005] = nil
		} else {
			{
				var zb0007 []byte
				zb0007, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.operatorDelegatorTVLs[za0005]))
				if err != nil {
					err = msgp.WrapError(err, "operatorDelegatorTVLs", za0005)
					return
				}
				z.operatorDelegatorTVLs[za0005] = msgpencode.DecodeInt(zb0007)
			}
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.totalTVL = nil
	} else {
		{
			var zb0008 []byte
			zb0008, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.totalTVL))
			if err != nil {
				err = msgp.WrapError(err, "totalTVL")
				return
			}
			z.totalTVL = msgpencode.DecodeInt(zb0008)
		}
	}
	var zb0009 uint32
	zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "operatorDelegatorAllocations")
		return
	}
	if cap(z.operatorDelegatorAllocations) >= int(zb0009) {
		z.operatorDelegatorAllocations = (z.operatorDelegatorAllocations)[:zb0009]
	} else {
		z.operatorDelegatorAllocations = make([]*big.Int, zb0009)
	}
	for za0006 := range z.operatorDelegatorAllocations {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			z.operatorDelegatorAllocations[za0006] = nil
		} else {
			{
				var zb0010 []byte
				zb0010, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.operatorDelegatorAllocations[za0006]))
				if err != nil {
					err = msgp.WrapError(err, "operatorDelegatorAllocations", za0006)
					return
				}
				z.operatorDelegatorAllocations[za0006] = msgpencode.DecodeInt(zb0010)
			}
		}
	}
	var zb0011 uint32
	zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "tokenStrategyMapping")
		return
	}
	if cap(z.tokenStrategyMapping) >= int(zb0011) {
		z.tokenStrategyMapping = (z.tokenStrategyMapping)[:zb0011]
	} else {
		z.tokenStrategyMapping = make([]map[string]bool, zb0011)
	}
	for za0007 := range z.tokenStrategyMapping {
		var zb0012 uint32
		zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "tokenStrategyMapping", za0007)
			return
		}
		if z.tokenStrategyMapping[za0007] == nil {
			z.tokenStrategyMapping[za0007] = make(map[string]bool, zb0012)
		} else if len(z.tokenStrategyMapping[za0007]) > 0 {
			for key := range z.tokenStrategyMapping[za0007] {
				delete(z.tokenStrategyMapping[za0007], key)
			}
		}
		for zb0012 > 0 {
			var za0008 string
			var za0009 bool
			zb0012--
			za0008, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "tokenStrategyMapping", za0007)
				return
			}
			za0009, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "tokenStrategyMapping", za0007, za0008)
				return
			}
			z.tokenStrategyMapping[za0007][za0008] = za0009
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.totalSupply = nil
	} else {
		{
			var zb0013 []byte
			zb0013, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.totalSupply))
			if err != nil {
				err = msgp.WrapError(err, "totalSupply")
				return
			}
			z.totalSupply = msgpencode.DecodeInt(zb0013)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.maxDepositTVL = nil
	} else {
		{
			var zb0014 []byte
			zb0014, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.maxDepositTVL))
			if err != nil {
				err = msgp.WrapError(err, "maxDepositTVL")
				return
			}
			z.maxDepositTVL = msgpencode.DecodeInt(zb0014)
		}
	}
	var zb0015 uint32
	zb0015, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "tokenOracleLookup")
		return
	}
	if z.tokenOracleLookup == nil {
		z.tokenOracleLookup = make(map[string]Oracle, zb0015)
	} else if len(z.tokenOracleLookup) > 0 {
		for key := range z.tokenOracleLookup {
			delete(z.tokenOracleLookup, key)
		}
	}
	for zb0015 > 0 {
		var za0010 string
		var za0011 Oracle
		zb0015--
		za0010, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup")
			return
		}
		bts, err = za0011.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "tokenOracleLookup", za0010)
			return
		}
		z.tokenOracleLookup[za0010] = za0011
	}
	var zb0016 uint32
	zb0016, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "collateralTokenTvlLimits")
		return
	}
	if z.collateralTokenTvlLimits == nil {
		z.collateralTokenTvlLimits = make(map[string]*big.Int, zb0016)
	} else if len(z.collateralTokenTvlLimits) > 0 {
		for key := range z.collateralTokenTvlLimits {
			delete(z.collateralTokenTvlLimits, key)
		}
	}
	for zb0016 > 0 {
		var za0012 string
		var za0013 *big.Int
		zb0016--
		za0012, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "collateralTokenTvlLimits")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0013 = nil
		} else {
			{
				var zb0017 []byte
				zb0017, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0013))
				if err != nil {
					err = msgp.WrapError(err, "collateralTokenTvlLimits", za0012)
					return
				}
				za0013 = msgpencode.DecodeInt(zb0017)
			}
		}
		z.collateralTokenTvlLimits[za0012] = za0013
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PoolSimulator) Msgsize() (s int) {
	s = 1 + z.Pool.Msgsize() + msgp.BoolSize + msgp.BoolSize + msgp.MapHeaderSize
	if z.collateralTokenIndex != nil {
		for za0001, za0002 := range z.collateralTokenIndex {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.IntSize
		}
	}
	s += msgp.ArrayHeaderSize
	for za0003 := range z.operatorDelegatorTokenTVLs {
		s += msgp.ArrayHeaderSize
		for za0004 := range z.operatorDelegatorTokenTVLs[za0003] {
			if z.operatorDelegatorTokenTVLs[za0003][za0004] == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.operatorDelegatorTokenTVLs[za0003][za0004]))
			}
		}
	}
	s += msgp.ArrayHeaderSize
	for za0005 := range z.operatorDelegatorTVLs {
		if z.operatorDelegatorTVLs[za0005] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.operatorDelegatorTVLs[za0005]))
		}
	}
	if z.totalTVL == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.totalTVL))
	}
	s += msgp.ArrayHeaderSize
	for za0006 := range z.operatorDelegatorAllocations {
		if z.operatorDelegatorAllocations[za0006] == nil {
			s += msgp.NilSize
		} else {
			s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.operatorDelegatorAllocations[za0006]))
		}
	}
	s += msgp.ArrayHeaderSize
	for za0007 := range z.tokenStrategyMapping {
		s += msgp.MapHeaderSize
		if z.tokenStrategyMapping[za0007] != nil {
			for za0008, za0009 := range z.tokenStrategyMapping[za0007] {
				_ = za0009
				s += msgp.StringPrefixSize + len(za0008) + msgp.BoolSize
			}
		}
	}
	if z.totalSupply == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.totalSupply))
	}
	if z.maxDepositTVL == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.maxDepositTVL))
	}
	s += msgp.MapHeaderSize
	if z.tokenOracleLookup != nil {
		for za0010, za0011 := range z.tokenOracleLookup {
			_ = za0011
			s += msgp.StringPrefixSize + len(za0010) + za0011.Msgsize()
		}
	}
	s += msgp.MapHeaderSize
	if z.collateralTokenTvlLimits != nil {
		for za0012, za0013 := range z.collateralTokenTvlLimits {
			_ = za0013
			s += msgp.StringPrefixSize + len(za0012)
			if za0013 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0013))
			}
		}
	}
	return
}

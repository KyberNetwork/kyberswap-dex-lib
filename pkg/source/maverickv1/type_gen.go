package maverickv1

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"math/big"

	"github.com/KyberNetwork/kyberswap-dex-lib/pkg/msgpencode"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Bin) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "ReserveA")
			return
		}
		z.ReserveA = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.ReserveA))
			if err != nil {
				err = msgp.WrapError(err, "ReserveA")
				return
			}
			z.ReserveA = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "ReserveB")
			return
		}
		z.ReserveB = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.ReserveB))
			if err != nil {
				err = msgp.WrapError(err, "ReserveB")
				return
			}
			z.ReserveB = msgpencode.DecodeInt(zb0003)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "LowerTick")
			return
		}
		z.LowerTick = nil
	} else {
		{
			var zb0004 []byte
			zb0004, err = dc.ReadBytes(msgpencode.EncodeInt(z.LowerTick))
			if err != nil {
				err = msgp.WrapError(err, "LowerTick")
				return
			}
			z.LowerTick = msgpencode.DecodeInt(zb0004)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Kind")
			return
		}
		z.Kind = nil
	} else {
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.Kind))
			if err != nil {
				err = msgp.WrapError(err, "Kind")
				return
			}
			z.Kind = msgpencode.DecodeInt(zb0005)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "MergeID")
			return
		}
		z.MergeID = nil
	} else {
		{
			var zb0006 []byte
			zb0006, err = dc.ReadBytes(msgpencode.EncodeInt(z.MergeID))
			if err != nil {
				err = msgp.WrapError(err, "MergeID")
				return
			}
			z.MergeID = msgpencode.DecodeInt(zb0006)
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Bin) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 5
	err = en.Append(0x95)
	if err != nil {
		return
	}
	if z.ReserveA == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.ReserveA))
		if err != nil {
			err = msgp.WrapError(err, "ReserveA")
			return
		}
	}
	if z.ReserveB == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.ReserveB))
		if err != nil {
			err = msgp.WrapError(err, "ReserveB")
			return
		}
	}
	if z.LowerTick == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.LowerTick))
		if err != nil {
			err = msgp.WrapError(err, "LowerTick")
			return
		}
	}
	if z.Kind == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Kind))
		if err != nil {
			err = msgp.WrapError(err, "Kind")
			return
		}
	}
	if z.MergeID == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.MergeID))
		if err != nil {
			err = msgp.WrapError(err, "MergeID")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Bin) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 5
	o = append(o, 0x95)
	if z.ReserveA == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.ReserveA))
	}
	if z.ReserveB == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.ReserveB))
	}
	if z.LowerTick == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.LowerTick))
	}
	if z.Kind == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Kind))
	}
	if z.MergeID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.MergeID))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bin) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.ReserveA = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.ReserveA))
			if err != nil {
				err = msgp.WrapError(err, "ReserveA")
				return
			}
			z.ReserveA = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.ReserveB = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.ReserveB))
			if err != nil {
				err = msgp.WrapError(err, "ReserveB")
				return
			}
			z.ReserveB = msgpencode.DecodeInt(zb0003)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.LowerTick = nil
	} else {
		{
			var zb0004 []byte
			zb0004, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.LowerTick))
			if err != nil {
				err = msgp.WrapError(err, "LowerTick")
				return
			}
			z.LowerTick = msgpencode.DecodeInt(zb0004)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Kind = nil
	} else {
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Kind))
			if err != nil {
				err = msgp.WrapError(err, "Kind")
				return
			}
			z.Kind = msgpencode.DecodeInt(zb0005)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.MergeID = nil
	} else {
		{
			var zb0006 []byte
			zb0006, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.MergeID))
			if err != nil {
				err = msgp.WrapError(err, "MergeID")
				return
			}
			z.MergeID = msgpencode.DecodeInt(zb0006)
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bin) Msgsize() (s int) {
	s = 1
	if z.ReserveA == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.ReserveA))
	}
	if z.ReserveB == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.ReserveB))
	}
	if z.LowerTick == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.LowerTick))
	}
	if z.Kind == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Kind))
	}
	if z.MergeID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.MergeID))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Gas) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Swap, err = dc.ReadInt64()
	if err != nil {
		err = msgp.WrapError(err, "Swap")
		return
	}
	z.CrossBin, err = dc.ReadInt64()
	if err != nil {
		err = msgp.WrapError(err, "CrossBin")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Gas) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Swap)
	if err != nil {
		err = msgp.WrapError(err, "Swap")
		return
	}
	err = en.WriteInt64(z.CrossBin)
	if err != nil {
		err = msgp.WrapError(err, "CrossBin")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Gas) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o = msgp.AppendInt64(o, z.Swap)
	o = msgp.AppendInt64(o, z.CrossBin)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Gas) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Swap, bts, err = msgp.ReadInt64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Swap")
		return
	}
	z.CrossBin, bts, err = msgp.ReadInt64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CrossBin")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Gas) Msgsize() (s int) {
	s = 1 + msgp.Int64Size + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MaverickPoolState) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 11 {
		err = msgp.ArrayError{Wanted: 11, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "TickSpacing")
			return
		}
		z.TickSpacing = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.TickSpacing))
			if err != nil {
				err = msgp.WrapError(err, "TickSpacing")
				return
			}
			z.TickSpacing = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Fee")
			return
		}
		z.Fee = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.Fee))
			if err != nil {
				err = msgp.WrapError(err, "Fee")
				return
			}
			z.Fee = msgpencode.DecodeInt(zb0003)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "ProtocolFeeRatio")
			return
		}
		z.ProtocolFeeRatio = nil
	} else {
		{
			var zb0004 []byte
			zb0004, err = dc.ReadBytes(msgpencode.EncodeInt(z.ProtocolFeeRatio))
			if err != nil {
				err = msgp.WrapError(err, "ProtocolFeeRatio")
				return
			}
			z.ProtocolFeeRatio = msgpencode.DecodeInt(zb0004)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "ActiveTick")
			return
		}
		z.ActiveTick = nil
	} else {
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.ActiveTick))
			if err != nil {
				err = msgp.WrapError(err, "ActiveTick")
				return
			}
			z.ActiveTick = msgpencode.DecodeInt(zb0005)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "BinCounter")
			return
		}
		z.BinCounter = nil
	} else {
		{
			var zb0006 []byte
			zb0006, err = dc.ReadBytes(msgpencode.EncodeInt(z.BinCounter))
			if err != nil {
				err = msgp.WrapError(err, "BinCounter")
				return
			}
			z.BinCounter = msgpencode.DecodeInt(zb0006)
		}
	}
	var zb0007 uint32
	zb0007, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "Bins")
		return
	}
	if z.Bins == nil {
		z.Bins = make(map[string]Bin, zb0007)
	} else if len(z.Bins) > 0 {
		for key := range z.Bins {
			delete(z.Bins, key)
		}
	}
	for zb0007 > 0 {
		zb0007--
		var za0001 string
		var za0002 Bin
		za0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "Bins")
			return
		}
		err = za0002.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "Bins", za0001)
			return
		}
		z.Bins[za0001] = za0002
	}
	var zb0008 uint32
	zb0008, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "BinPositions")
		return
	}
	if z.BinPositions == nil {
		z.BinPositions = make(map[string]map[string]*big.Int, zb0008)
	} else if len(z.BinPositions) > 0 {
		for key := range z.BinPositions {
			delete(z.BinPositions, key)
		}
	}
	for zb0008 > 0 {
		zb0008--
		var za0003 string
		var za0004 map[string]*big.Int
		za0003, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "BinPositions")
			return
		}
		var zb0009 uint32
		zb0009, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, "BinPositions", za0003)
			return
		}
		if za0004 == nil {
			za0004 = make(map[string]*big.Int, zb0009)
		} else if len(za0004) > 0 {
			for key := range za0004 {
				delete(za0004, key)
			}
		}
		for zb0009 > 0 {
			zb0009--
			var za0005 string
			var za0006 *big.Int
			za0005, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BinPositions", za0003)
				return
			}
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BinPositions", za0003, za0005)
					return
				}
				za0006 = nil
			} else {
				{
					var zb0010 []byte
					zb0010, err = dc.ReadBytes(msgpencode.EncodeInt(za0006))
					if err != nil {
						err = msgp.WrapError(err, "BinPositions", za0003, za0005)
						return
					}
					za0006 = msgpencode.DecodeInt(zb0010)
				}
			}
			za0004[za0005] = za0006
		}
		z.BinPositions[za0003] = za0004
	}
	var zb0011 uint32
	zb0011, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "BinMap")
		return
	}
	if z.BinMap == nil {
		z.BinMap = make(map[string]*big.Int, zb0011)
	} else if len(z.BinMap) > 0 {
		for key := range z.BinMap {
			delete(z.BinMap, key)
		}
	}
	for zb0011 > 0 {
		zb0011--
		var za0007 string
		var za0008 *big.Int
		za0007, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "BinMap")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "BinMap", za0007)
				return
			}
			za0008 = nil
		} else {
			{
				var zb0012 []byte
				zb0012, err = dc.ReadBytes(msgpencode.EncodeInt(za0008))
				if err != nil {
					err = msgp.WrapError(err, "BinMap", za0007)
					return
				}
				za0008 = msgpencode.DecodeInt(zb0012)
			}
		}
		z.BinMap[za0007] = za0008
	}
	var zb0013 uint32
	zb0013, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "BinMapHex")
		return
	}
	if z.BinMapHex == nil {
		z.BinMapHex = make(map[string]*big.Int, zb0013)
	} else if len(z.BinMapHex) > 0 {
		for key := range z.BinMapHex {
			delete(z.BinMapHex, key)
		}
	}
	for zb0013 > 0 {
		zb0013--
		var za0009 string
		var za0010 *big.Int
		za0009, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "BinMapHex")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "BinMapHex", za0009)
				return
			}
			za0010 = nil
		} else {
			{
				var zb0014 []byte
				zb0014, err = dc.ReadBytes(msgpencode.EncodeInt(za0010))
				if err != nil {
					err = msgp.WrapError(err, "BinMapHex", za0009)
					return
				}
				za0010 = msgpencode.DecodeInt(zb0014)
			}
		}
		z.BinMapHex[za0009] = za0010
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "minBinMapIndex")
			return
		}
		z.minBinMapIndex = nil
	} else {
		{
			var zb0015 []byte
			zb0015, err = dc.ReadBytes(msgpencode.EncodeInt(z.minBinMapIndex))
			if err != nil {
				err = msgp.WrapError(err, "minBinMapIndex")
				return
			}
			z.minBinMapIndex = msgpencode.DecodeInt(zb0015)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "maxBinMapIndex")
			return
		}
		z.maxBinMapIndex = nil
	} else {
		{
			var zb0016 []byte
			zb0016, err = dc.ReadBytes(msgpencode.EncodeInt(z.maxBinMapIndex))
			if err != nil {
				err = msgp.WrapError(err, "maxBinMapIndex")
				return
			}
			z.maxBinMapIndex = msgpencode.DecodeInt(zb0016)
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MaverickPoolState) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 11
	err = en.Append(0x9b)
	if err != nil {
		return
	}
	if z.TickSpacing == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.TickSpacing))
		if err != nil {
			err = msgp.WrapError(err, "TickSpacing")
			return
		}
	}
	if z.Fee == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Fee))
		if err != nil {
			err = msgp.WrapError(err, "Fee")
			return
		}
	}
	if z.ProtocolFeeRatio == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.ProtocolFeeRatio))
		if err != nil {
			err = msgp.WrapError(err, "ProtocolFeeRatio")
			return
		}
	}
	if z.ActiveTick == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.ActiveTick))
		if err != nil {
			err = msgp.WrapError(err, "ActiveTick")
			return
		}
	}
	if z.BinCounter == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.BinCounter))
		if err != nil {
			err = msgp.WrapError(err, "BinCounter")
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.Bins)))
	if err != nil {
		err = msgp.WrapError(err, "Bins")
		return
	}
	for za0001, za0002 := range z.Bins {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Bins")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Bins", za0001)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.BinPositions)))
	if err != nil {
		err = msgp.WrapError(err, "BinPositions")
		return
	}
	for za0003, za0004 := range z.BinPositions {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "BinPositions")
			return
		}
		err = en.WriteMapHeader(uint32(len(za0004)))
		if err != nil {
			err = msgp.WrapError(err, "BinPositions", za0003)
			return
		}
		for za0005, za0006 := range za0004 {
			err = en.WriteString(za0005)
			if err != nil {
				err = msgp.WrapError(err, "BinPositions", za0003)
				return
			}
			if za0006 == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteBytes(msgpencode.EncodeInt(za0006))
				if err != nil {
					err = msgp.WrapError(err, "BinPositions", za0003, za0005)
					return
				}
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.BinMap)))
	if err != nil {
		err = msgp.WrapError(err, "BinMap")
		return
	}
	for za0007, za0008 := range z.BinMap {
		err = en.WriteString(za0007)
		if err != nil {
			err = msgp.WrapError(err, "BinMap")
			return
		}
		if za0008 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0008))
			if err != nil {
				err = msgp.WrapError(err, "BinMap", za0007)
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.BinMapHex)))
	if err != nil {
		err = msgp.WrapError(err, "BinMapHex")
		return
	}
	for za0009, za0010 := range z.BinMapHex {
		err = en.WriteString(za0009)
		if err != nil {
			err = msgp.WrapError(err, "BinMapHex")
			return
		}
		if za0010 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0010))
			if err != nil {
				err = msgp.WrapError(err, "BinMapHex", za0009)
				return
			}
		}
	}
	if z.minBinMapIndex == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.minBinMapIndex))
		if err != nil {
			err = msgp.WrapError(err, "minBinMapIndex")
			return
		}
	}
	if z.maxBinMapIndex == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.maxBinMapIndex))
		if err != nil {
			err = msgp.WrapError(err, "maxBinMapIndex")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MaverickPoolState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 11
	o = append(o, 0x9b)
	if z.TickSpacing == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.TickSpacing))
	}
	if z.Fee == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Fee))
	}
	if z.ProtocolFeeRatio == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.ProtocolFeeRatio))
	}
	if z.ActiveTick == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.ActiveTick))
	}
	if z.BinCounter == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.BinCounter))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.Bins)))
	for za0001, za0002 := range z.Bins {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Bins", za0001)
			return
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.BinPositions)))
	for za0003, za0004 := range z.BinPositions {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendMapHeader(o, uint32(len(za0004)))
		for za0005, za0006 := range za0004 {
			o = msgp.AppendString(o, za0005)
			if za0006 == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0006))
			}
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.BinMap)))
	for za0007, za0008 := range z.BinMap {
		o = msgp.AppendString(o, za0007)
		if za0008 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0008))
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.BinMapHex)))
	for za0009, za0010 := range z.BinMapHex {
		o = msgp.AppendString(o, za0009)
		if za0010 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0010))
		}
	}
	if z.minBinMapIndex == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.minBinMapIndex))
	}
	if z.maxBinMapIndex == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.maxBinMapIndex))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MaverickPoolState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 11 {
		err = msgp.ArrayError{Wanted: 11, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.TickSpacing = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.TickSpacing))
			if err != nil {
				err = msgp.WrapError(err, "TickSpacing")
				return
			}
			z.TickSpacing = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Fee = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Fee))
			if err != nil {
				err = msgp.WrapError(err, "Fee")
				return
			}
			z.Fee = msgpencode.DecodeInt(zb0003)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.ProtocolFeeRatio = nil
	} else {
		{
			var zb0004 []byte
			zb0004, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.ProtocolFeeRatio))
			if err != nil {
				err = msgp.WrapError(err, "ProtocolFeeRatio")
				return
			}
			z.ProtocolFeeRatio = msgpencode.DecodeInt(zb0004)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.ActiveTick = nil
	} else {
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.ActiveTick))
			if err != nil {
				err = msgp.WrapError(err, "ActiveTick")
				return
			}
			z.ActiveTick = msgpencode.DecodeInt(zb0005)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.BinCounter = nil
	} else {
		{
			var zb0006 []byte
			zb0006, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.BinCounter))
			if err != nil {
				err = msgp.WrapError(err, "BinCounter")
				return
			}
			z.BinCounter = msgpencode.DecodeInt(zb0006)
		}
	}
	var zb0007 uint32
	zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Bins")
		return
	}
	if z.Bins == nil {
		z.Bins = make(map[string]Bin, zb0007)
	} else if len(z.Bins) > 0 {
		for key := range z.Bins {
			delete(z.Bins, key)
		}
	}
	for zb0007 > 0 {
		var za0001 string
		var za0002 Bin
		zb0007--
		za0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "Bins")
			return
		}
		bts, err = za0002.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "Bins", za0001)
			return
		}
		z.Bins[za0001] = za0002
	}
	var zb0008 uint32
	zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BinPositions")
		return
	}
	if z.BinPositions == nil {
		z.BinPositions = make(map[string]map[string]*big.Int, zb0008)
	} else if len(z.BinPositions) > 0 {
		for key := range z.BinPositions {
			delete(z.BinPositions, key)
		}
	}
	for zb0008 > 0 {
		var za0003 string
		var za0004 map[string]*big.Int
		zb0008--
		za0003, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "BinPositions")
			return
		}
		var zb0009 uint32
		zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "BinPositions", za0003)
			return
		}
		if za0004 == nil {
			za0004 = make(map[string]*big.Int, zb0009)
		} else if len(za0004) > 0 {
			for key := range za0004 {
				delete(za0004, key)
			}
		}
		for zb0009 > 0 {
			var za0005 string
			var za0006 *big.Int
			zb0009--
			za0005, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BinPositions", za0003)
				return
			}
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				za0006 = nil
			} else {
				{
					var zb0010 []byte
					zb0010, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0006))
					if err != nil {
						err = msgp.WrapError(err, "BinPositions", za0003, za0005)
						return
					}
					za0006 = msgpencode.DecodeInt(zb0010)
				}
			}
			za0004[za0005] = za0006
		}
		z.BinPositions[za0003] = za0004
	}
	var zb0011 uint32
	zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BinMap")
		return
	}
	if z.BinMap == nil {
		z.BinMap = make(map[string]*big.Int, zb0011)
	} else if len(z.BinMap) > 0 {
		for key := range z.BinMap {
			delete(z.BinMap, key)
		}
	}
	for zb0011 > 0 {
		var za0007 string
		var za0008 *big.Int
		zb0011--
		za0007, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "BinMap")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0008 = nil
		} else {
			{
				var zb0012 []byte
				zb0012, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0008))
				if err != nil {
					err = msgp.WrapError(err, "BinMap", za0007)
					return
				}
				za0008 = msgpencode.DecodeInt(zb0012)
			}
		}
		z.BinMap[za0007] = za0008
	}
	var zb0013 uint32
	zb0013, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BinMapHex")
		return
	}
	if z.BinMapHex == nil {
		z.BinMapHex = make(map[string]*big.Int, zb0013)
	} else if len(z.BinMapHex) > 0 {
		for key := range z.BinMapHex {
			delete(z.BinMapHex, key)
		}
	}
	for zb0013 > 0 {
		var za0009 string
		var za0010 *big.Int
		zb0013--
		za0009, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "BinMapHex")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0010 = nil
		} else {
			{
				var zb0014 []byte
				zb0014, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0010))
				if err != nil {
					err = msgp.WrapError(err, "BinMapHex", za0009)
					return
				}
				za0010 = msgpencode.DecodeInt(zb0014)
			}
		}
		z.BinMapHex[za0009] = za0010
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.minBinMapIndex = nil
	} else {
		{
			var zb0015 []byte
			zb0015, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.minBinMapIndex))
			if err != nil {
				err = msgp.WrapError(err, "minBinMapIndex")
				return
			}
			z.minBinMapIndex = msgpencode.DecodeInt(zb0015)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.maxBinMapIndex = nil
	} else {
		{
			var zb0016 []byte
			zb0016, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.maxBinMapIndex))
			if err != nil {
				err = msgp.WrapError(err, "maxBinMapIndex")
				return
			}
			z.maxBinMapIndex = msgpencode.DecodeInt(zb0016)
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MaverickPoolState) Msgsize() (s int) {
	s = 1
	if z.TickSpacing == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.TickSpacing))
	}
	if z.Fee == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Fee))
	}
	if z.ProtocolFeeRatio == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.ProtocolFeeRatio))
	}
	if z.ActiveTick == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.ActiveTick))
	}
	if z.BinCounter == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.BinCounter))
	}
	s += msgp.MapHeaderSize
	if z.Bins != nil {
		for za0001, za0002 := range z.Bins {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += msgp.MapHeaderSize
	if z.BinPositions != nil {
		for za0003, za0004 := range z.BinPositions {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.MapHeaderSize
			if za0004 != nil {
				for za0005, za0006 := range za0004 {
					_ = za0006
					s += msgp.StringPrefixSize + len(za0005)
					if za0006 == nil {
						s += msgp.NilSize
					} else {
						s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0006))
					}
				}
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.BinMap != nil {
		for za0007, za0008 := range z.BinMap {
			_ = za0008
			s += msgp.StringPrefixSize + len(za0007)
			if za0008 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0008))
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.BinMapHex != nil {
		for za0009, za0010 := range z.BinMapHex {
			_ = za0010
			s += msgp.StringPrefixSize + len(za0009)
			if za0010 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0010))
			}
		}
	}
	if z.minBinMapIndex == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.minBinMapIndex))
	}
	if z.maxBinMapIndex == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.maxBinMapIndex))
	}
	return
}

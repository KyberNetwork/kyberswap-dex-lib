package synthetix

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"math/big"

	"github.com/KyberNetwork/kyberswap-dex-lib/pkg/msgpencode"
	"github.com/ethereum/go-ethereum/common"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Addresses) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.Synthetix, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Synthetix")
		return
	}
	z.Exchanger, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Exchanger")
		return
	}
	z.ExchangeRates, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "ExchangeRates")
		return
	}
	z.SystemSettings, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "SystemSettings")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Addresses) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return
	}
	err = en.WriteString(z.Synthetix)
	if err != nil {
		err = msgp.WrapError(err, "Synthetix")
		return
	}
	err = en.WriteString(z.Exchanger)
	if err != nil {
		err = msgp.WrapError(err, "Exchanger")
		return
	}
	err = en.WriteString(z.ExchangeRates)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeRates")
		return
	}
	err = en.WriteString(z.SystemSettings)
	if err != nil {
		err = msgp.WrapError(err, "SystemSettings")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Addresses) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendString(o, z.Synthetix)
	o = msgp.AppendString(o, z.Exchanger)
	o = msgp.AppendString(o, z.ExchangeRates)
	o = msgp.AppendString(o, z.SystemSettings)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Addresses) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.Synthetix, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Synthetix")
		return
	}
	z.Exchanger, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Exchanger")
		return
	}
	z.ExchangeRates, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeRates")
		return
	}
	z.SystemSettings, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "SystemSettings")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Addresses) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Synthetix) + msgp.StringPrefixSize + len(z.Exchanger) + msgp.StringPrefixSize + len(z.ExchangeRates) + msgp.StringPrefixSize + len(z.SystemSettings)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ChainlinkDataFeed) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "RoundID")
			return
		}
		z.RoundID = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.RoundID))
			if err != nil {
				err = msgp.WrapError(err, "RoundID")
				return
			}
			z.RoundID = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Answer")
			return
		}
		z.Answer = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.Answer))
			if err != nil {
				err = msgp.WrapError(err, "Answer")
				return
			}
			z.Answer = msgpencode.DecodeInt(zb0003)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "StartedAt")
			return
		}
		z.StartedAt = nil
	} else {
		{
			var zb0004 []byte
			zb0004, err = dc.ReadBytes(msgpencode.EncodeInt(z.StartedAt))
			if err != nil {
				err = msgp.WrapError(err, "StartedAt")
				return
			}
			z.StartedAt = msgpencode.DecodeInt(zb0004)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "UpdatedAt")
			return
		}
		z.UpdatedAt = nil
	} else {
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.UpdatedAt))
			if err != nil {
				err = msgp.WrapError(err, "UpdatedAt")
				return
			}
			z.UpdatedAt = msgpencode.DecodeInt(zb0005)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "AnsweredInRound")
			return
		}
		z.AnsweredInRound = nil
	} else {
		{
			var zb0006 []byte
			zb0006, err = dc.ReadBytes(msgpencode.EncodeInt(z.AnsweredInRound))
			if err != nil {
				err = msgp.WrapError(err, "AnsweredInRound")
				return
			}
			z.AnsweredInRound = msgpencode.DecodeInt(zb0006)
		}
	}
	var zb0007 uint32
	zb0007, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "Answers")
		return
	}
	if z.Answers == nil {
		z.Answers = make(map[string]RoundData, zb0007)
	} else if len(z.Answers) > 0 {
		for key := range z.Answers {
			delete(z.Answers, key)
		}
	}
	for zb0007 > 0 {
		zb0007--
		var za0001 string
		var za0002 RoundData
		za0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "Answers")
			return
		}
		err = za0002.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "Answers", za0001)
			return
		}
		z.Answers[za0001] = za0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ChainlinkDataFeed) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return
	}
	if z.RoundID == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.RoundID))
		if err != nil {
			err = msgp.WrapError(err, "RoundID")
			return
		}
	}
	if z.Answer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Answer))
		if err != nil {
			err = msgp.WrapError(err, "Answer")
			return
		}
	}
	if z.StartedAt == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.StartedAt))
		if err != nil {
			err = msgp.WrapError(err, "StartedAt")
			return
		}
	}
	if z.UpdatedAt == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.UpdatedAt))
		if err != nil {
			err = msgp.WrapError(err, "UpdatedAt")
			return
		}
	}
	if z.AnsweredInRound == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.AnsweredInRound))
		if err != nil {
			err = msgp.WrapError(err, "AnsweredInRound")
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.Answers)))
	if err != nil {
		err = msgp.WrapError(err, "Answers")
		return
	}
	for za0001, za0002 := range z.Answers {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Answers")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Answers", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ChainlinkDataFeed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	if z.RoundID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.RoundID))
	}
	if z.Answer == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Answer))
	}
	if z.StartedAt == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.StartedAt))
	}
	if z.UpdatedAt == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.UpdatedAt))
	}
	if z.AnsweredInRound == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.AnsweredInRound))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.Answers)))
	for za0001, za0002 := range z.Answers {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Answers", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ChainlinkDataFeed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.RoundID = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.RoundID))
			if err != nil {
				err = msgp.WrapError(err, "RoundID")
				return
			}
			z.RoundID = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Answer = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Answer))
			if err != nil {
				err = msgp.WrapError(err, "Answer")
				return
			}
			z.Answer = msgpencode.DecodeInt(zb0003)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.StartedAt = nil
	} else {
		{
			var zb0004 []byte
			zb0004, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.StartedAt))
			if err != nil {
				err = msgp.WrapError(err, "StartedAt")
				return
			}
			z.StartedAt = msgpencode.DecodeInt(zb0004)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.UpdatedAt = nil
	} else {
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.UpdatedAt))
			if err != nil {
				err = msgp.WrapError(err, "UpdatedAt")
				return
			}
			z.UpdatedAt = msgpencode.DecodeInt(zb0005)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.AnsweredInRound = nil
	} else {
		{
			var zb0006 []byte
			zb0006, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.AnsweredInRound))
			if err != nil {
				err = msgp.WrapError(err, "AnsweredInRound")
				return
			}
			z.AnsweredInRound = msgpencode.DecodeInt(zb0006)
		}
	}
	var zb0007 uint32
	zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Answers")
		return
	}
	if z.Answers == nil {
		z.Answers = make(map[string]RoundData, zb0007)
	} else if len(z.Answers) > 0 {
		for key := range z.Answers {
			delete(z.Answers, key)
		}
	}
	for zb0007 > 0 {
		var za0001 string
		var za0002 RoundData
		zb0007--
		za0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "Answers")
			return
		}
		bts, err = za0002.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "Answers", za0001)
			return
		}
		z.Answers[za0001] = za0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ChainlinkDataFeed) Msgsize() (s int) {
	s = 1
	if z.RoundID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.RoundID))
	}
	if z.Answer == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Answer))
	}
	if z.StartedAt == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.StartedAt))
	}
	if z.UpdatedAt == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.UpdatedAt))
	}
	if z.AnsweredInRound == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.AnsweredInRound))
	}
	s += msgp.MapHeaderSize
	if z.Answers != nil {
		for za0001, za0002 := range z.Answers {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DexPriceAggregatorUniswapV3) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 8 {
		err = msgp.ArrayError{Wanted: 8, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "DefaultPoolFee")
			return
		}
		z.DefaultPoolFee = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.DefaultPoolFee))
			if err != nil {
				err = msgp.WrapError(err, "DefaultPoolFee")
				return
			}
			z.DefaultPoolFee = msgpencode.DecodeInt(zb0002)
		}
	}
	{
		var zb0003 []byte
		zb0003, err = dc.ReadBytes((common.Address).Bytes(z.UniswapV3Factory))
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Factory")
			return
		}
		z.UniswapV3Factory = common.BytesToAddress(zb0003)
	}
	{
		var zb0004 []byte
		zb0004, err = dc.ReadBytes((common.Address).Bytes(z.Weth))
		if err != nil {
			err = msgp.WrapError(err, "Weth")
			return
		}
		z.Weth = common.BytesToAddress(zb0004)
	}
	z.BlockTimestamp, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	var zb0005 uint32
	zb0005, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "OverriddenPoolForRoute")
		return
	}
	if z.OverriddenPoolForRoute == nil {
		z.OverriddenPoolForRoute = make(map[string]common.Address, zb0005)
	} else if len(z.OverriddenPoolForRoute) > 0 {
		for key := range z.OverriddenPoolForRoute {
			delete(z.OverriddenPoolForRoute, key)
		}
	}
	for zb0005 > 0 {
		zb0005--
		var za0001 string
		var za0002 common.Address
		za0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "OverriddenPoolForRoute")
			return
		}
		{
			var zb0006 []byte
			zb0006, err = dc.ReadBytes((common.Address).Bytes(za0002))
			if err != nil {
				err = msgp.WrapError(err, "OverriddenPoolForRoute", za0001)
				return
			}
			za0002 = common.BytesToAddress(zb0006)
		}
		z.OverriddenPoolForRoute[za0001] = za0002
	}
	var zb0007 uint32
	zb0007, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Slot0")
		return
	}
	if z.UniswapV3Slot0 == nil {
		z.UniswapV3Slot0 = make(map[string]Slot0, zb0007)
	} else if len(z.UniswapV3Slot0) > 0 {
		for key := range z.UniswapV3Slot0 {
			delete(z.UniswapV3Slot0, key)
		}
	}
	for zb0007 > 0 {
		zb0007--
		var za0003 string
		var za0004 Slot0
		za0003, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0")
			return
		}
		err = za0004.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0", za0003)
			return
		}
		z.UniswapV3Slot0[za0003] = za0004
	}
	var zb0008 uint32
	zb0008, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Observations")
		return
	}
	if z.UniswapV3Observations == nil {
		z.UniswapV3Observations = make(map[string]map[string]OracleObservation, zb0008)
	} else if len(z.UniswapV3Observations) > 0 {
		for key := range z.UniswapV3Observations {
			delete(z.UniswapV3Observations, key)
		}
	}
	for zb0008 > 0 {
		zb0008--
		var za0005 string
		var za0006 map[string]OracleObservation
		za0005, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Observations")
			return
		}
		var zb0009 uint32
		zb0009, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Observations", za0005)
			return
		}
		if za0006 == nil {
			za0006 = make(map[string]OracleObservation, zb0009)
		} else if len(za0006) > 0 {
			for key := range za0006 {
				delete(za0006, key)
			}
		}
		for zb0009 > 0 {
			zb0009--
			var za0007 string
			var za0008 OracleObservation
			za0007, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005)
				return
			}
			err = za0008.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005, za0007)
				return
			}
			za0006[za0007] = za0008
		}
		z.UniswapV3Observations[za0005] = za0006
	}
	var zb0010 uint32
	zb0010, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "TickCumulatives")
		return
	}
	if z.TickCumulatives == nil {
		z.TickCumulatives = make(map[string][]*big.Int, zb0010)
	} else if len(z.TickCumulatives) > 0 {
		for key := range z.TickCumulatives {
			delete(z.TickCumulatives, key)
		}
	}
	for zb0010 > 0 {
		zb0010--
		var za0009 string
		var za0010 []*big.Int
		za0009, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "TickCumulatives")
			return
		}
		var zb0011 uint32
		zb0011, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, "TickCumulatives", za0009)
			return
		}
		if cap(za0010) >= int(zb0011) {
			za0010 = (za0010)[:zb0011]
		} else {
			za0010 = make([]*big.Int, zb0011)
		}
		for za0011 := range za0010 {
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TickCumulatives", za0009, za0011)
					return
				}
				za0010[za0011] = nil
			} else {
				{
					var zb0012 []byte
					zb0012, err = dc.ReadBytes(msgpencode.EncodeInt(za0010[za0011]))
					if err != nil {
						err = msgp.WrapError(err, "TickCumulatives", za0009, za0011)
						return
					}
					za0010[za0011] = msgpencode.DecodeInt(zb0012)
				}
			}
		}
		z.TickCumulatives[za0009] = za0010
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DexPriceAggregatorUniswapV3) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 8
	err = en.Append(0x98)
	if err != nil {
		return
	}
	if z.DefaultPoolFee == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.DefaultPoolFee))
		if err != nil {
			err = msgp.WrapError(err, "DefaultPoolFee")
			return
		}
	}
	err = en.WriteBytes((common.Address).Bytes(z.UniswapV3Factory))
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Factory")
		return
	}
	err = en.WriteBytes((common.Address).Bytes(z.Weth))
	if err != nil {
		err = msgp.WrapError(err, "Weth")
		return
	}
	err = en.WriteUint64(z.BlockTimestamp)
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	err = en.WriteMapHeader(uint32(len(z.OverriddenPoolForRoute)))
	if err != nil {
		err = msgp.WrapError(err, "OverriddenPoolForRoute")
		return
	}
	for za0001, za0002 := range z.OverriddenPoolForRoute {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "OverriddenPoolForRoute")
			return
		}
		err = en.WriteBytes((common.Address).Bytes(za0002))
		if err != nil {
			err = msgp.WrapError(err, "OverriddenPoolForRoute", za0001)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.UniswapV3Slot0)))
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Slot0")
		return
	}
	for za0003, za0004 := range z.UniswapV3Slot0 {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0")
			return
		}
		err = za0004.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0", za0003)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.UniswapV3Observations)))
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Observations")
		return
	}
	for za0005, za0006 := range z.UniswapV3Observations {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Observations")
			return
		}
		err = en.WriteMapHeader(uint32(len(za0006)))
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Observations", za0005)
			return
		}
		for za0007, za0008 := range za0006 {
			err = en.WriteString(za0007)
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005)
				return
			}
			err = za0008.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005, za0007)
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.TickCumulatives)))
	if err != nil {
		err = msgp.WrapError(err, "TickCumulatives")
		return
	}
	for za0009, za0010 := range z.TickCumulatives {
		err = en.WriteString(za0009)
		if err != nil {
			err = msgp.WrapError(err, "TickCumulatives")
			return
		}
		err = en.WriteArrayHeader(uint32(len(za0010)))
		if err != nil {
			err = msgp.WrapError(err, "TickCumulatives", za0009)
			return
		}
		for za0011 := range za0010 {
			if za0010[za0011] == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteBytes(msgpencode.EncodeInt(za0010[za0011]))
				if err != nil {
					err = msgp.WrapError(err, "TickCumulatives", za0009, za0011)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DexPriceAggregatorUniswapV3) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 8
	o = append(o, 0x98)
	if z.DefaultPoolFee == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.DefaultPoolFee))
	}
	o = msgp.AppendBytes(o, (common.Address).Bytes(z.UniswapV3Factory))
	o = msgp.AppendBytes(o, (common.Address).Bytes(z.Weth))
	o = msgp.AppendUint64(o, z.BlockTimestamp)
	o = msgp.AppendMapHeader(o, uint32(len(z.OverriddenPoolForRoute)))
	for za0001, za0002 := range z.OverriddenPoolForRoute {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendBytes(o, (common.Address).Bytes(za0002))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.UniswapV3Slot0)))
	for za0003, za0004 := range z.UniswapV3Slot0 {
		o = msgp.AppendString(o, za0003)
		o, err = za0004.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0", za0003)
			return
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.UniswapV3Observations)))
	for za0005, za0006 := range z.UniswapV3Observations {
		o = msgp.AppendString(o, za0005)
		o = msgp.AppendMapHeader(o, uint32(len(za0006)))
		for za0007, za0008 := range za0006 {
			o = msgp.AppendString(o, za0007)
			o, err = za0008.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005, za0007)
				return
			}
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.TickCumulatives)))
	for za0009, za0010 := range z.TickCumulatives {
		o = msgp.AppendString(o, za0009)
		o = msgp.AppendArrayHeader(o, uint32(len(za0010)))
		for za0011 := range za0010 {
			if za0010[za0011] == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0010[za0011]))
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DexPriceAggregatorUniswapV3) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 8 {
		err = msgp.ArrayError{Wanted: 8, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.DefaultPoolFee = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.DefaultPoolFee))
			if err != nil {
				err = msgp.WrapError(err, "DefaultPoolFee")
				return
			}
			z.DefaultPoolFee = msgpencode.DecodeInt(zb0002)
		}
	}
	{
		var zb0003 []byte
		zb0003, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(z.UniswapV3Factory))
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Factory")
			return
		}
		z.UniswapV3Factory = common.BytesToAddress(zb0003)
	}
	{
		var zb0004 []byte
		zb0004, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(z.Weth))
		if err != nil {
			err = msgp.WrapError(err, "Weth")
			return
		}
		z.Weth = common.BytesToAddress(zb0004)
	}
	z.BlockTimestamp, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	var zb0005 uint32
	zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "OverriddenPoolForRoute")
		return
	}
	if z.OverriddenPoolForRoute == nil {
		z.OverriddenPoolForRoute = make(map[string]common.Address, zb0005)
	} else if len(z.OverriddenPoolForRoute) > 0 {
		for key := range z.OverriddenPoolForRoute {
			delete(z.OverriddenPoolForRoute, key)
		}
	}
	for zb0005 > 0 {
		var za0001 string
		var za0002 common.Address
		zb0005--
		za0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "OverriddenPoolForRoute")
			return
		}
		{
			var zb0006 []byte
			zb0006, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(za0002))
			if err != nil {
				err = msgp.WrapError(err, "OverriddenPoolForRoute", za0001)
				return
			}
			za0002 = common.BytesToAddress(zb0006)
		}
		z.OverriddenPoolForRoute[za0001] = za0002
	}
	var zb0007 uint32
	zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Slot0")
		return
	}
	if z.UniswapV3Slot0 == nil {
		z.UniswapV3Slot0 = make(map[string]Slot0, zb0007)
	} else if len(z.UniswapV3Slot0) > 0 {
		for key := range z.UniswapV3Slot0 {
			delete(z.UniswapV3Slot0, key)
		}
	}
	for zb0007 > 0 {
		var za0003 string
		var za0004 Slot0
		zb0007--
		za0003, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0")
			return
		}
		bts, err = za0004.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Slot0", za0003)
			return
		}
		z.UniswapV3Slot0[za0003] = za0004
	}
	var zb0008 uint32
	zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "UniswapV3Observations")
		return
	}
	if z.UniswapV3Observations == nil {
		z.UniswapV3Observations = make(map[string]map[string]OracleObservation, zb0008)
	} else if len(z.UniswapV3Observations) > 0 {
		for key := range z.UniswapV3Observations {
			delete(z.UniswapV3Observations, key)
		}
	}
	for zb0008 > 0 {
		var za0005 string
		var za0006 map[string]OracleObservation
		zb0008--
		za0005, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Observations")
			return
		}
		var zb0009 uint32
		zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "UniswapV3Observations", za0005)
			return
		}
		if za0006 == nil {
			za0006 = make(map[string]OracleObservation, zb0009)
		} else if len(za0006) > 0 {
			for key := range za0006 {
				delete(za0006, key)
			}
		}
		for zb0009 > 0 {
			var za0007 string
			var za0008 OracleObservation
			zb0009--
			za0007, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005)
				return
			}
			bts, err = za0008.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "UniswapV3Observations", za0005, za0007)
				return
			}
			za0006[za0007] = za0008
		}
		z.UniswapV3Observations[za0005] = za0006
	}
	var zb0010 uint32
	zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "TickCumulatives")
		return
	}
	if z.TickCumulatives == nil {
		z.TickCumulatives = make(map[string][]*big.Int, zb0010)
	} else if len(z.TickCumulatives) > 0 {
		for key := range z.TickCumulatives {
			delete(z.TickCumulatives, key)
		}
	}
	for zb0010 > 0 {
		var za0009 string
		var za0010 []*big.Int
		zb0010--
		za0009, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "TickCumulatives")
			return
		}
		var zb0011 uint32
		zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "TickCumulatives", za0009)
			return
		}
		if cap(za0010) >= int(zb0011) {
			za0010 = (za0010)[:zb0011]
		} else {
			za0010 = make([]*big.Int, zb0011)
		}
		for za0011 := range za0010 {
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				za0010[za0011] = nil
			} else {
				{
					var zb0012 []byte
					zb0012, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0010[za0011]))
					if err != nil {
						err = msgp.WrapError(err, "TickCumulatives", za0009, za0011)
						return
					}
					za0010[za0011] = msgpencode.DecodeInt(zb0012)
				}
			}
		}
		z.TickCumulatives[za0009] = za0010
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DexPriceAggregatorUniswapV3) Msgsize() (s int) {
	s = 1
	if z.DefaultPoolFee == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.DefaultPoolFee))
	}
	s += msgp.BytesPrefixSize + len((common.Address).Bytes(z.UniswapV3Factory)) + msgp.BytesPrefixSize + len((common.Address).Bytes(z.Weth)) + msgp.Uint64Size + msgp.MapHeaderSize
	if z.OverriddenPoolForRoute != nil {
		for za0001, za0002 := range z.OverriddenPoolForRoute {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.BytesPrefixSize + len((common.Address).Bytes(za0002))
		}
	}
	s += msgp.MapHeaderSize
	if z.UniswapV3Slot0 != nil {
		for za0003, za0004 := range z.UniswapV3Slot0 {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += msgp.MapHeaderSize
	if z.UniswapV3Observations != nil {
		for za0005, za0006 := range z.UniswapV3Observations {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.MapHeaderSize
			if za0006 != nil {
				for za0007, za0008 := range za0006 {
					_ = za0008
					s += msgp.StringPrefixSize + len(za0007) + za0008.Msgsize()
				}
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.TickCumulatives != nil {
		for za0009, za0010 := range z.TickCumulatives {
			_ = za0010
			s += msgp.StringPrefixSize + len(za0009) + msgp.ArrayHeaderSize
			for za0011 := range za0010 {
				if za0010[za0011] == nil {
					s += msgp.NilSize
				} else {
					s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0010[za0011]))
				}
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DynamicFeeConfig) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Threshold")
			return
		}
		z.Threshold = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.Threshold))
			if err != nil {
				err = msgp.WrapError(err, "Threshold")
				return
			}
			z.Threshold = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "WeightDecay")
			return
		}
		z.WeightDecay = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.WeightDecay))
			if err != nil {
				err = msgp.WrapError(err, "WeightDecay")
				return
			}
			z.WeightDecay = msgpencode.DecodeInt(zb0003)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Rounds")
			return
		}
		z.Rounds = nil
	} else {
		{
			var zb0004 []byte
			zb0004, err = dc.ReadBytes(msgpencode.EncodeInt(z.Rounds))
			if err != nil {
				err = msgp.WrapError(err, "Rounds")
				return
			}
			z.Rounds = msgpencode.DecodeInt(zb0004)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "MaxFee")
			return
		}
		z.MaxFee = nil
	} else {
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.MaxFee))
			if err != nil {
				err = msgp.WrapError(err, "MaxFee")
				return
			}
			z.MaxFee = msgpencode.DecodeInt(zb0005)
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DynamicFeeConfig) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return
	}
	if z.Threshold == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Threshold))
		if err != nil {
			err = msgp.WrapError(err, "Threshold")
			return
		}
	}
	if z.WeightDecay == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.WeightDecay))
		if err != nil {
			err = msgp.WrapError(err, "WeightDecay")
			return
		}
	}
	if z.Rounds == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Rounds))
		if err != nil {
			err = msgp.WrapError(err, "Rounds")
			return
		}
	}
	if z.MaxFee == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.MaxFee))
		if err != nil {
			err = msgp.WrapError(err, "MaxFee")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DynamicFeeConfig) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	if z.Threshold == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Threshold))
	}
	if z.WeightDecay == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.WeightDecay))
	}
	if z.Rounds == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Rounds))
	}
	if z.MaxFee == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.MaxFee))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DynamicFeeConfig) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Threshold = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Threshold))
			if err != nil {
				err = msgp.WrapError(err, "Threshold")
				return
			}
			z.Threshold = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.WeightDecay = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.WeightDecay))
			if err != nil {
				err = msgp.WrapError(err, "WeightDecay")
				return
			}
			z.WeightDecay = msgpencode.DecodeInt(zb0003)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Rounds = nil
	} else {
		{
			var zb0004 []byte
			zb0004, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Rounds))
			if err != nil {
				err = msgp.WrapError(err, "Rounds")
				return
			}
			z.Rounds = msgpencode.DecodeInt(zb0004)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.MaxFee = nil
	} else {
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.MaxFee))
			if err != nil {
				err = msgp.WrapError(err, "MaxFee")
				return
			}
			z.MaxFee = msgpencode.DecodeInt(zb0005)
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DynamicFeeConfig) Msgsize() (s int) {
	s = 1
	if z.Threshold == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Threshold))
	}
	if z.WeightDecay == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.WeightDecay))
	}
	if z.Rounds == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Rounds))
	}
	if z.MaxFee == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.MaxFee))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ExchangeVolumeAtPeriod) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Time, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Volume")
			return
		}
		z.Volume = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.Volume))
			if err != nil {
				err = msgp.WrapError(err, "Volume")
				return
			}
			z.Volume = msgpencode.DecodeInt(zb0002)
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ExchangeVolumeAtPeriod) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Time)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	if z.Volume == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Volume))
		if err != nil {
			err = msgp.WrapError(err, "Volume")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ExchangeVolumeAtPeriod) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o = msgp.AppendUint64(o, z.Time)
	if z.Volume == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Volume))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ExchangeVolumeAtPeriod) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Time, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Time")
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Volume = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Volume))
			if err != nil {
				err = msgp.WrapError(err, "Volume")
				return
			}
			z.Volume = msgpencode.DecodeInt(zb0002)
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ExchangeVolumeAtPeriod) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size
	if z.Volume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Volume))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OracleObservation) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.BlockTimestamp, err = dc.ReadUint32()
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "TickCumulative")
			return
		}
		z.TickCumulative = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.TickCumulative))
			if err != nil {
				err = msgp.WrapError(err, "TickCumulative")
				return
			}
			z.TickCumulative = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "SecondsPerLiquidityCumulativeX128")
			return
		}
		z.SecondsPerLiquidityCumulativeX128 = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.SecondsPerLiquidityCumulativeX128))
			if err != nil {
				err = msgp.WrapError(err, "SecondsPerLiquidityCumulativeX128")
				return
			}
			z.SecondsPerLiquidityCumulativeX128 = msgpencode.DecodeInt(zb0003)
		}
	}
	z.Initialized, err = dc.ReadBool()
	if err != nil {
		err = msgp.WrapError(err, "Initialized")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OracleObservation) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.BlockTimestamp)
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	if z.TickCumulative == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.TickCumulative))
		if err != nil {
			err = msgp.WrapError(err, "TickCumulative")
			return
		}
	}
	if z.SecondsPerLiquidityCumulativeX128 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.SecondsPerLiquidityCumulativeX128))
		if err != nil {
			err = msgp.WrapError(err, "SecondsPerLiquidityCumulativeX128")
			return
		}
	}
	err = en.WriteBool(z.Initialized)
	if err != nil {
		err = msgp.WrapError(err, "Initialized")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OracleObservation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendUint32(o, z.BlockTimestamp)
	if z.TickCumulative == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.TickCumulative))
	}
	if z.SecondsPerLiquidityCumulativeX128 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.SecondsPerLiquidityCumulativeX128))
	}
	o = msgp.AppendBool(o, z.Initialized)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OracleObservation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.BlockTimestamp, bts, err = msgp.ReadUint32Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.TickCumulative = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.TickCumulative))
			if err != nil {
				err = msgp.WrapError(err, "TickCumulative")
				return
			}
			z.TickCumulative = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.SecondsPerLiquidityCumulativeX128 = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.SecondsPerLiquidityCumulativeX128))
			if err != nil {
				err = msgp.WrapError(err, "SecondsPerLiquidityCumulativeX128")
				return
			}
			z.SecondsPerLiquidityCumulativeX128 = msgpencode.DecodeInt(zb0003)
		}
	}
	z.Initialized, bts, err = msgp.ReadBoolBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Initialized")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OracleObservation) Msgsize() (s int) {
	s = 1 + msgp.Uint32Size
	if z.TickCumulative == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.TickCumulative))
	}
	if z.SecondsPerLiquidityCumulativeX128 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.SecondsPerLiquidityCumulativeX128))
	}
	s += msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PoolState) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 19 {
		err = msgp.ArrayError{Wanted: 19, Got: zb0001}
		return
	}
	z.BlockTimestamp, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "Synths")
		return
	}
	if z.Synths == nil {
		z.Synths = make(map[string]common.Address, zb0002)
	} else if len(z.Synths) > 0 {
		for key := range z.Synths {
			delete(z.Synths, key)
		}
	}
	for zb0002 > 0 {
		zb0002--
		var za0001 string
		var za0002 common.Address
		za0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "Synths")
			return
		}
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes((common.Address).Bytes(za0002))
			if err != nil {
				err = msgp.WrapError(err, "Synths", za0001)
				return
			}
			za0002 = common.BytesToAddress(zb0003)
		}
		z.Synths[za0001] = za0002
	}
	var zb0004 uint32
	zb0004, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp")
		return
	}
	if z.CurrencyKeyBySynthMsgp == nil {
		z.CurrencyKeyBySynthMsgp = make(map[string]string, zb0004)
	} else if len(z.CurrencyKeyBySynthMsgp) > 0 {
		for key := range z.CurrencyKeyBySynthMsgp {
			delete(z.CurrencyKeyBySynthMsgp, key)
		}
	}
	for zb0004 > 0 {
		zb0004--
		var za0003 string
		var za0004 string
		za0003, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp")
			return
		}
		za0004, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp", za0003)
			return
		}
		z.CurrencyKeyBySynthMsgp[za0003] = za0004
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "AvailableSynthCount")
			return
		}
		z.AvailableSynthCount = nil
	} else {
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.AvailableSynthCount))
			if err != nil {
				err = msgp.WrapError(err, "AvailableSynthCount")
				return
			}
			z.AvailableSynthCount = msgpencode.DecodeInt(zb0005)
		}
	}
	var zb0006 uint32
	zb0006, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "SynthsTotalSupply")
		return
	}
	if z.SynthsTotalSupply == nil {
		z.SynthsTotalSupply = make(map[string]*big.Int, zb0006)
	} else if len(z.SynthsTotalSupply) > 0 {
		for key := range z.SynthsTotalSupply {
			delete(z.SynthsTotalSupply, key)
		}
	}
	for zb0006 > 0 {
		zb0006--
		var za0005 string
		var za0006 *big.Int
		za0005, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "SynthsTotalSupply")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "SynthsTotalSupply", za0005)
				return
			}
			za0006 = nil
		} else {
			{
				var zb0007 []byte
				zb0007, err = dc.ReadBytes(msgpencode.EncodeInt(za0006))
				if err != nil {
					err = msgp.WrapError(err, "SynthsTotalSupply", za0005)
					return
				}
				za0006 = msgpencode.DecodeInt(zb0007)
			}
		}
		z.SynthsTotalSupply[za0005] = za0006
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "TotalIssuedSUSD")
			return
		}
		z.TotalIssuedSUSD = nil
	} else {
		{
			var zb0008 []byte
			zb0008, err = dc.ReadBytes(msgpencode.EncodeInt(z.TotalIssuedSUSD))
			if err != nil {
				err = msgp.WrapError(err, "TotalIssuedSUSD")
				return
			}
			z.TotalIssuedSUSD = msgpencode.DecodeInt(zb0008)
		}
	}
	var zb0009 uint32
	zb0009, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeys")
		return
	}
	if cap(z.CurrencyKeys) >= int(zb0009) {
		z.CurrencyKeys = (z.CurrencyKeys)[:zb0009]
	} else {
		z.CurrencyKeys = make([]string, zb0009)
	}
	for za0007 := range z.CurrencyKeys {
		z.CurrencyKeys[za0007], err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeys", za0007)
			return
		}
	}
	z.SUSDCurrencyKey, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "SUSDCurrencyKey")
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Addresses")
			return
		}
		z.Addresses = nil
	} else {
		if z.Addresses == nil {
			z.Addresses = new(Addresses)
		}
		err = z.Addresses.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "Addresses")
			return
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "SystemSettings")
			return
		}
		z.SystemSettings = nil
	} else {
		if z.SystemSettings == nil {
			z.SystemSettings = new(SystemSettings)
		}
		err = z.SystemSettings.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "SystemSettings")
			return
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "AtomicMaxVolumePerBlock")
			return
		}
		z.AtomicMaxVolumePerBlock = nil
	} else {
		{
			var zb0010 []byte
			zb0010, err = dc.ReadBytes(msgpencode.EncodeInt(z.AtomicMaxVolumePerBlock))
			if err != nil {
				err = msgp.WrapError(err, "AtomicMaxVolumePerBlock")
				return
			}
			z.AtomicMaxVolumePerBlock = msgpencode.DecodeInt(zb0010)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "LastAtomicVolume")
			return
		}
		z.LastAtomicVolume = nil
	} else {
		if z.LastAtomicVolume == nil {
			z.LastAtomicVolume = new(ExchangeVolumeAtPeriod)
		}
		var zb0011 uint32
		zb0011, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, "LastAtomicVolume")
			return
		}
		if zb0011 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zb0011}
			return
		}
		z.LastAtomicVolume.Time, err = dc.ReadUint64()
		if err != nil {
			err = msgp.WrapError(err, "LastAtomicVolume", "Time")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "LastAtomicVolume", "Volume")
				return
			}
			z.LastAtomicVolume.Volume = nil
		} else {
			{
				var zb0012 []byte
				zb0012, err = dc.ReadBytes(msgpencode.EncodeInt(z.LastAtomicVolume.Volume))
				if err != nil {
					err = msgp.WrapError(err, "LastAtomicVolume", "Volume")
					return
				}
				z.LastAtomicVolume.Volume = msgpencode.DecodeInt(zb0012)
			}
		}
	}
	var zb0013 uint32
	zb0013, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "AggregatorAddresses")
		return
	}
	if z.AggregatorAddresses == nil {
		z.AggregatorAddresses = make(map[string]common.Address, zb0013)
	} else if len(z.AggregatorAddresses) > 0 {
		for key := range z.AggregatorAddresses {
			delete(z.AggregatorAddresses, key)
		}
	}
	for zb0013 > 0 {
		zb0013--
		var za0008 string
		var za0009 common.Address
		za0008, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AggregatorAddresses")
			return
		}
		{
			var zb0014 []byte
			zb0014, err = dc.ReadBytes((common.Address).Bytes(za0009))
			if err != nil {
				err = msgp.WrapError(err, "AggregatorAddresses", za0008)
				return
			}
			za0009 = common.BytesToAddress(zb0014)
		}
		z.AggregatorAddresses[za0008] = za0009
	}
	var zb0015 uint32
	zb0015, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeyDecimals")
		return
	}
	if z.CurrencyKeyDecimals == nil {
		z.CurrencyKeyDecimals = make(map[string]uint8, zb0015)
	} else if len(z.CurrencyKeyDecimals) > 0 {
		for key := range z.CurrencyKeyDecimals {
			delete(z.CurrencyKeyDecimals, key)
		}
	}
	for zb0015 > 0 {
		zb0015--
		var za0010 string
		var za0011 uint8
		za0010, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyDecimals")
			return
		}
		za0011, err = dc.ReadUint8()
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyDecimals", za0010)
			return
		}
		z.CurrencyKeyDecimals[za0010] = za0011
	}
	var zb0016 uint32
	zb0016, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "CurrentRoundIds")
		return
	}
	if z.CurrentRoundIds == nil {
		z.CurrentRoundIds = make(map[string]*big.Int, zb0016)
	} else if len(z.CurrentRoundIds) > 0 {
		for key := range z.CurrentRoundIds {
			delete(z.CurrentRoundIds, key)
		}
	}
	for zb0016 > 0 {
		zb0016--
		var za0012 string
		var za0013 *big.Int
		za0012, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "CurrentRoundIds")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "CurrentRoundIds", za0012)
				return
			}
			za0013 = nil
		} else {
			{
				var zb0017 []byte
				zb0017, err = dc.ReadBytes(msgpencode.EncodeInt(za0013))
				if err != nil {
					err = msgp.WrapError(err, "CurrentRoundIds", za0012)
					return
				}
				za0013 = msgpencode.DecodeInt(zb0017)
			}
		}
		z.CurrentRoundIds[za0012] = za0013
	}
	var zb0018 uint32
	zb0018, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges")
		return
	}
	if z.SynthTooVolatileForAtomicExchanges == nil {
		z.SynthTooVolatileForAtomicExchanges = make(map[string]bool, zb0018)
	} else if len(z.SynthTooVolatileForAtomicExchanges) > 0 {
		for key := range z.SynthTooVolatileForAtomicExchanges {
			delete(z.SynthTooVolatileForAtomicExchanges, key)
		}
	}
	for zb0018 > 0 {
		zb0018--
		var za0014 string
		var za0015 bool
		za0014, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges")
			return
		}
		za0015, err = dc.ReadBool()
		if err != nil {
			err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges", za0014)
			return
		}
		z.SynthTooVolatileForAtomicExchanges[za0014] = za0015
	}
	{
		var zb0019 []byte
		zb0019, err = dc.ReadBytes((common.Address).Bytes(z.DexPriceAggregatorAddress))
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregatorAddress")
			return
		}
		z.DexPriceAggregatorAddress = common.BytesToAddress(zb0019)
	}
	var zb0020 uint32
	zb0020, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "Aggregators")
		return
	}
	if z.Aggregators == nil {
		z.Aggregators = make(map[string]*ChainlinkDataFeed, zb0020)
	} else if len(z.Aggregators) > 0 {
		for key := range z.Aggregators {
			delete(z.Aggregators, key)
		}
	}
	for zb0020 > 0 {
		zb0020--
		var za0016 string
		var za0017 *ChainlinkDataFeed
		za0016, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "Aggregators")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "Aggregators", za0016)
				return
			}
			za0017 = nil
		} else {
			if za0017 == nil {
				za0017 = new(ChainlinkDataFeed)
			}
			err = za0017.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Aggregators", za0016)
				return
			}
		}
		z.Aggregators[za0016] = za0017
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregator")
			return
		}
		z.DexPriceAggregator = nil
	} else {
		if z.DexPriceAggregator == nil {
			z.DexPriceAggregator = new(DexPriceAggregatorUniswapV3)
		}
		err = z.DexPriceAggregator.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregator")
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PoolState) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 19
	err = en.Append(0xdc, 0x0, 0x13)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BlockTimestamp)
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Synths)))
	if err != nil {
		err = msgp.WrapError(err, "Synths")
		return
	}
	for za0001, za0002 := range z.Synths {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Synths")
			return
		}
		err = en.WriteBytes((common.Address).Bytes(za0002))
		if err != nil {
			err = msgp.WrapError(err, "Synths", za0001)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.CurrencyKeyBySynthMsgp)))
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp")
		return
	}
	for za0003, za0004 := range z.CurrencyKeyBySynthMsgp {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp")
			return
		}
		err = en.WriteString(za0004)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp", za0003)
			return
		}
	}
	if z.AvailableSynthCount == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.AvailableSynthCount))
		if err != nil {
			err = msgp.WrapError(err, "AvailableSynthCount")
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.SynthsTotalSupply)))
	if err != nil {
		err = msgp.WrapError(err, "SynthsTotalSupply")
		return
	}
	for za0005, za0006 := range z.SynthsTotalSupply {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "SynthsTotalSupply")
			return
		}
		if za0006 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0006))
			if err != nil {
				err = msgp.WrapError(err, "SynthsTotalSupply", za0005)
				return
			}
		}
	}
	if z.TotalIssuedSUSD == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.TotalIssuedSUSD))
		if err != nil {
			err = msgp.WrapError(err, "TotalIssuedSUSD")
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.CurrencyKeys)))
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeys")
		return
	}
	for za0007 := range z.CurrencyKeys {
		err = en.WriteString(z.CurrencyKeys[za0007])
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeys", za0007)
			return
		}
	}
	err = en.WriteString(z.SUSDCurrencyKey)
	if err != nil {
		err = msgp.WrapError(err, "SUSDCurrencyKey")
		return
	}
	if z.Addresses == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Addresses.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Addresses")
			return
		}
	}
	if z.SystemSettings == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.SystemSettings.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "SystemSettings")
			return
		}
	}
	if z.AtomicMaxVolumePerBlock == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.AtomicMaxVolumePerBlock))
		if err != nil {
			err = msgp.WrapError(err, "AtomicMaxVolumePerBlock")
			return
		}
	}
	if z.LastAtomicVolume == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.LastAtomicVolume.Time)
		if err != nil {
			err = msgp.WrapError(err, "LastAtomicVolume", "Time")
			return
		}
		if z.LastAtomicVolume.Volume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(z.LastAtomicVolume.Volume))
			if err != nil {
				err = msgp.WrapError(err, "LastAtomicVolume", "Volume")
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.AggregatorAddresses)))
	if err != nil {
		err = msgp.WrapError(err, "AggregatorAddresses")
		return
	}
	for za0008, za0009 := range z.AggregatorAddresses {
		err = en.WriteString(za0008)
		if err != nil {
			err = msgp.WrapError(err, "AggregatorAddresses")
			return
		}
		err = en.WriteBytes((common.Address).Bytes(za0009))
		if err != nil {
			err = msgp.WrapError(err, "AggregatorAddresses", za0008)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.CurrencyKeyDecimals)))
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeyDecimals")
		return
	}
	for za0010, za0011 := range z.CurrencyKeyDecimals {
		err = en.WriteString(za0010)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyDecimals")
			return
		}
		err = en.WriteUint8(za0011)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyDecimals", za0010)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.CurrentRoundIds)))
	if err != nil {
		err = msgp.WrapError(err, "CurrentRoundIds")
		return
	}
	for za0012, za0013 := range z.CurrentRoundIds {
		err = en.WriteString(za0012)
		if err != nil {
			err = msgp.WrapError(err, "CurrentRoundIds")
			return
		}
		if za0013 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0013))
			if err != nil {
				err = msgp.WrapError(err, "CurrentRoundIds", za0012)
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.SynthTooVolatileForAtomicExchanges)))
	if err != nil {
		err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges")
		return
	}
	for za0014, za0015 := range z.SynthTooVolatileForAtomicExchanges {
		err = en.WriteString(za0014)
		if err != nil {
			err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges")
			return
		}
		err = en.WriteBool(za0015)
		if err != nil {
			err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges", za0014)
			return
		}
	}
	err = en.WriteBytes((common.Address).Bytes(z.DexPriceAggregatorAddress))
	if err != nil {
		err = msgp.WrapError(err, "DexPriceAggregatorAddress")
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Aggregators)))
	if err != nil {
		err = msgp.WrapError(err, "Aggregators")
		return
	}
	for za0016, za0017 := range z.Aggregators {
		err = en.WriteString(za0016)
		if err != nil {
			err = msgp.WrapError(err, "Aggregators")
			return
		}
		if za0017 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = za0017.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Aggregators", za0016)
				return
			}
		}
	}
	if z.DexPriceAggregator == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.DexPriceAggregator.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregator")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PoolState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 19
	o = append(o, 0xdc, 0x0, 0x13)
	o = msgp.AppendUint64(o, z.BlockTimestamp)
	o = msgp.AppendMapHeader(o, uint32(len(z.Synths)))
	for za0001, za0002 := range z.Synths {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendBytes(o, (common.Address).Bytes(za0002))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.CurrencyKeyBySynthMsgp)))
	for za0003, za0004 := range z.CurrencyKeyBySynthMsgp {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendString(o, za0004)
	}
	if z.AvailableSynthCount == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.AvailableSynthCount))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.SynthsTotalSupply)))
	for za0005, za0006 := range z.SynthsTotalSupply {
		o = msgp.AppendString(o, za0005)
		if za0006 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0006))
		}
	}
	if z.TotalIssuedSUSD == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.TotalIssuedSUSD))
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.CurrencyKeys)))
	for za0007 := range z.CurrencyKeys {
		o = msgp.AppendString(o, z.CurrencyKeys[za0007])
	}
	o = msgp.AppendString(o, z.SUSDCurrencyKey)
	if z.Addresses == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Addresses.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Addresses")
			return
		}
	}
	if z.SystemSettings == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.SystemSettings.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SystemSettings")
			return
		}
	}
	if z.AtomicMaxVolumePerBlock == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.AtomicMaxVolumePerBlock))
	}
	if z.LastAtomicVolume == nil {
		o = msgp.AppendNil(o)
	} else {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.LastAtomicVolume.Time)
		if z.LastAtomicVolume.Volume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.LastAtomicVolume.Volume))
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.AggregatorAddresses)))
	for za0008, za0009 := range z.AggregatorAddresses {
		o = msgp.AppendString(o, za0008)
		o = msgp.AppendBytes(o, (common.Address).Bytes(za0009))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.CurrencyKeyDecimals)))
	for za0010, za0011 := range z.CurrencyKeyDecimals {
		o = msgp.AppendString(o, za0010)
		o = msgp.AppendUint8(o, za0011)
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.CurrentRoundIds)))
	for za0012, za0013 := range z.CurrentRoundIds {
		o = msgp.AppendString(o, za0012)
		if za0013 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0013))
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.SynthTooVolatileForAtomicExchanges)))
	for za0014, za0015 := range z.SynthTooVolatileForAtomicExchanges {
		o = msgp.AppendString(o, za0014)
		o = msgp.AppendBool(o, za0015)
	}
	o = msgp.AppendBytes(o, (common.Address).Bytes(z.DexPriceAggregatorAddress))
	o = msgp.AppendMapHeader(o, uint32(len(z.Aggregators)))
	for za0016, za0017 := range z.Aggregators {
		o = msgp.AppendString(o, za0016)
		if za0017 == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = za0017.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Aggregators", za0016)
				return
			}
		}
	}
	if z.DexPriceAggregator == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.DexPriceAggregator.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregator")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PoolState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 19 {
		err = msgp.ArrayError{Wanted: 19, Got: zb0001}
		return
	}
	z.BlockTimestamp, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "BlockTimestamp")
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Synths")
		return
	}
	if z.Synths == nil {
		z.Synths = make(map[string]common.Address, zb0002)
	} else if len(z.Synths) > 0 {
		for key := range z.Synths {
			delete(z.Synths, key)
		}
	}
	for zb0002 > 0 {
		var za0001 string
		var za0002 common.Address
		zb0002--
		za0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "Synths")
			return
		}
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(za0002))
			if err != nil {
				err = msgp.WrapError(err, "Synths", za0001)
				return
			}
			za0002 = common.BytesToAddress(zb0003)
		}
		z.Synths[za0001] = za0002
	}
	var zb0004 uint32
	zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp")
		return
	}
	if z.CurrencyKeyBySynthMsgp == nil {
		z.CurrencyKeyBySynthMsgp = make(map[string]string, zb0004)
	} else if len(z.CurrencyKeyBySynthMsgp) > 0 {
		for key := range z.CurrencyKeyBySynthMsgp {
			delete(z.CurrencyKeyBySynthMsgp, key)
		}
	}
	for zb0004 > 0 {
		var za0003 string
		var za0004 string
		zb0004--
		za0003, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp")
			return
		}
		za0004, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyBySynthMsgp", za0003)
			return
		}
		z.CurrencyKeyBySynthMsgp[za0003] = za0004
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.AvailableSynthCount = nil
	} else {
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.AvailableSynthCount))
			if err != nil {
				err = msgp.WrapError(err, "AvailableSynthCount")
				return
			}
			z.AvailableSynthCount = msgpencode.DecodeInt(zb0005)
		}
	}
	var zb0006 uint32
	zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "SynthsTotalSupply")
		return
	}
	if z.SynthsTotalSupply == nil {
		z.SynthsTotalSupply = make(map[string]*big.Int, zb0006)
	} else if len(z.SynthsTotalSupply) > 0 {
		for key := range z.SynthsTotalSupply {
			delete(z.SynthsTotalSupply, key)
		}
	}
	for zb0006 > 0 {
		var za0005 string
		var za0006 *big.Int
		zb0006--
		za0005, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "SynthsTotalSupply")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0006 = nil
		} else {
			{
				var zb0007 []byte
				zb0007, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0006))
				if err != nil {
					err = msgp.WrapError(err, "SynthsTotalSupply", za0005)
					return
				}
				za0006 = msgpencode.DecodeInt(zb0007)
			}
		}
		z.SynthsTotalSupply[za0005] = za0006
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.TotalIssuedSUSD = nil
	} else {
		{
			var zb0008 []byte
			zb0008, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.TotalIssuedSUSD))
			if err != nil {
				err = msgp.WrapError(err, "TotalIssuedSUSD")
				return
			}
			z.TotalIssuedSUSD = msgpencode.DecodeInt(zb0008)
		}
	}
	var zb0009 uint32
	zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeys")
		return
	}
	if cap(z.CurrencyKeys) >= int(zb0009) {
		z.CurrencyKeys = (z.CurrencyKeys)[:zb0009]
	} else {
		z.CurrencyKeys = make([]string, zb0009)
	}
	for za0007 := range z.CurrencyKeys {
		z.CurrencyKeys[za0007], bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeys", za0007)
			return
		}
	}
	z.SUSDCurrencyKey, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "SUSDCurrencyKey")
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Addresses = nil
	} else {
		if z.Addresses == nil {
			z.Addresses = new(Addresses)
		}
		bts, err = z.Addresses.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "Addresses")
			return
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.SystemSettings = nil
	} else {
		if z.SystemSettings == nil {
			z.SystemSettings = new(SystemSettings)
		}
		bts, err = z.SystemSettings.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "SystemSettings")
			return
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.AtomicMaxVolumePerBlock = nil
	} else {
		{
			var zb0010 []byte
			zb0010, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.AtomicMaxVolumePerBlock))
			if err != nil {
				err = msgp.WrapError(err, "AtomicMaxVolumePerBlock")
				return
			}
			z.AtomicMaxVolumePerBlock = msgpencode.DecodeInt(zb0010)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.LastAtomicVolume = nil
	} else {
		if z.LastAtomicVolume == nil {
			z.LastAtomicVolume = new(ExchangeVolumeAtPeriod)
		}
		var zb0011 uint32
		zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "LastAtomicVolume")
			return
		}
		if zb0011 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zb0011}
			return
		}
		z.LastAtomicVolume.Time, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "LastAtomicVolume", "Time")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			z.LastAtomicVolume.Volume = nil
		} else {
			{
				var zb0012 []byte
				zb0012, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.LastAtomicVolume.Volume))
				if err != nil {
					err = msgp.WrapError(err, "LastAtomicVolume", "Volume")
					return
				}
				z.LastAtomicVolume.Volume = msgpencode.DecodeInt(zb0012)
			}
		}
	}
	var zb0013 uint32
	zb0013, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AggregatorAddresses")
		return
	}
	if z.AggregatorAddresses == nil {
		z.AggregatorAddresses = make(map[string]common.Address, zb0013)
	} else if len(z.AggregatorAddresses) > 0 {
		for key := range z.AggregatorAddresses {
			delete(z.AggregatorAddresses, key)
		}
	}
	for zb0013 > 0 {
		var za0008 string
		var za0009 common.Address
		zb0013--
		za0008, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AggregatorAddresses")
			return
		}
		{
			var zb0014 []byte
			zb0014, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(za0009))
			if err != nil {
				err = msgp.WrapError(err, "AggregatorAddresses", za0008)
				return
			}
			za0009 = common.BytesToAddress(zb0014)
		}
		z.AggregatorAddresses[za0008] = za0009
	}
	var zb0015 uint32
	zb0015, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CurrencyKeyDecimals")
		return
	}
	if z.CurrencyKeyDecimals == nil {
		z.CurrencyKeyDecimals = make(map[string]uint8, zb0015)
	} else if len(z.CurrencyKeyDecimals) > 0 {
		for key := range z.CurrencyKeyDecimals {
			delete(z.CurrencyKeyDecimals, key)
		}
	}
	for zb0015 > 0 {
		var za0010 string
		var za0011 uint8
		zb0015--
		za0010, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyDecimals")
			return
		}
		za0011, bts, err = msgp.ReadUint8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "CurrencyKeyDecimals", za0010)
			return
		}
		z.CurrencyKeyDecimals[za0010] = za0011
	}
	var zb0016 uint32
	zb0016, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "CurrentRoundIds")
		return
	}
	if z.CurrentRoundIds == nil {
		z.CurrentRoundIds = make(map[string]*big.Int, zb0016)
	} else if len(z.CurrentRoundIds) > 0 {
		for key := range z.CurrentRoundIds {
			delete(z.CurrentRoundIds, key)
		}
	}
	for zb0016 > 0 {
		var za0012 string
		var za0013 *big.Int
		zb0016--
		za0012, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "CurrentRoundIds")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0013 = nil
		} else {
			{
				var zb0017 []byte
				zb0017, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0013))
				if err != nil {
					err = msgp.WrapError(err, "CurrentRoundIds", za0012)
					return
				}
				za0013 = msgpencode.DecodeInt(zb0017)
			}
		}
		z.CurrentRoundIds[za0012] = za0013
	}
	var zb0018 uint32
	zb0018, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges")
		return
	}
	if z.SynthTooVolatileForAtomicExchanges == nil {
		z.SynthTooVolatileForAtomicExchanges = make(map[string]bool, zb0018)
	} else if len(z.SynthTooVolatileForAtomicExchanges) > 0 {
		for key := range z.SynthTooVolatileForAtomicExchanges {
			delete(z.SynthTooVolatileForAtomicExchanges, key)
		}
	}
	for zb0018 > 0 {
		var za0014 string
		var za0015 bool
		zb0018--
		za0014, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges")
			return
		}
		za0015, bts, err = msgp.ReadBoolBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "SynthTooVolatileForAtomicExchanges", za0014)
			return
		}
		z.SynthTooVolatileForAtomicExchanges[za0014] = za0015
	}
	{
		var zb0019 []byte
		zb0019, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(z.DexPriceAggregatorAddress))
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregatorAddress")
			return
		}
		z.DexPriceAggregatorAddress = common.BytesToAddress(zb0019)
	}
	var zb0020 uint32
	zb0020, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Aggregators")
		return
	}
	if z.Aggregators == nil {
		z.Aggregators = make(map[string]*ChainlinkDataFeed, zb0020)
	} else if len(z.Aggregators) > 0 {
		for key := range z.Aggregators {
			delete(z.Aggregators, key)
		}
	}
	for zb0020 > 0 {
		var za0016 string
		var za0017 *ChainlinkDataFeed
		zb0020--
		za0016, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "Aggregators")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0017 = nil
		} else {
			if za0017 == nil {
				za0017 = new(ChainlinkDataFeed)
			}
			bts, err = za0017.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Aggregators", za0016)
				return
			}
		}
		z.Aggregators[za0016] = za0017
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.DexPriceAggregator = nil
	} else {
		if z.DexPriceAggregator == nil {
			z.DexPriceAggregator = new(DexPriceAggregatorUniswapV3)
		}
		bts, err = z.DexPriceAggregator.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "DexPriceAggregator")
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PoolState) Msgsize() (s int) {
	s = 3 + msgp.Uint64Size + msgp.MapHeaderSize
	if z.Synths != nil {
		for za0001, za0002 := range z.Synths {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.BytesPrefixSize + len((common.Address).Bytes(za0002))
		}
	}
	s += msgp.MapHeaderSize
	if z.CurrencyKeyBySynthMsgp != nil {
		for za0003, za0004 := range z.CurrencyKeyBySynthMsgp {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.StringPrefixSize + len(za0004)
		}
	}
	if z.AvailableSynthCount == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.AvailableSynthCount))
	}
	s += msgp.MapHeaderSize
	if z.SynthsTotalSupply != nil {
		for za0005, za0006 := range z.SynthsTotalSupply {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005)
			if za0006 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0006))
			}
		}
	}
	if z.TotalIssuedSUSD == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.TotalIssuedSUSD))
	}
	s += msgp.ArrayHeaderSize
	for za0007 := range z.CurrencyKeys {
		s += msgp.StringPrefixSize + len(z.CurrencyKeys[za0007])
	}
	s += msgp.StringPrefixSize + len(z.SUSDCurrencyKey)
	if z.Addresses == nil {
		s += msgp.NilSize
	} else {
		s += z.Addresses.Msgsize()
	}
	if z.SystemSettings == nil {
		s += msgp.NilSize
	} else {
		s += z.SystemSettings.Msgsize()
	}
	if z.AtomicMaxVolumePerBlock == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.AtomicMaxVolumePerBlock))
	}
	if z.LastAtomicVolume == nil {
		s += msgp.NilSize
	} else {
		s += 1 + msgp.Uint64Size
		if z.LastAtomicVolume.Volume == nil {
			s += msgp.NilSize
		} else {
			s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.LastAtomicVolume.Volume))
		}
	}
	s += msgp.MapHeaderSize
	if z.AggregatorAddresses != nil {
		for za0008, za0009 := range z.AggregatorAddresses {
			_ = za0009
			s += msgp.StringPrefixSize + len(za0008) + msgp.BytesPrefixSize + len((common.Address).Bytes(za0009))
		}
	}
	s += msgp.MapHeaderSize
	if z.CurrencyKeyDecimals != nil {
		for za0010, za0011 := range z.CurrencyKeyDecimals {
			_ = za0011
			s += msgp.StringPrefixSize + len(za0010) + msgp.Uint8Size
		}
	}
	s += msgp.MapHeaderSize
	if z.CurrentRoundIds != nil {
		for za0012, za0013 := range z.CurrentRoundIds {
			_ = za0013
			s += msgp.StringPrefixSize + len(za0012)
			if za0013 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0013))
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.SynthTooVolatileForAtomicExchanges != nil {
		for za0014, za0015 := range z.SynthTooVolatileForAtomicExchanges {
			_ = za0015
			s += msgp.StringPrefixSize + len(za0014) + msgp.BoolSize
		}
	}
	s += msgp.BytesPrefixSize + len((common.Address).Bytes(z.DexPriceAggregatorAddress)) + msgp.MapHeaderSize
	if z.Aggregators != nil {
		for za0016, za0017 := range z.Aggregators {
			_ = za0017
			s += msgp.StringPrefixSize + len(za0016)
			if za0017 == nil {
				s += msgp.NilSize
			} else {
				s += za0017.Msgsize()
			}
		}
	}
	if z.DexPriceAggregator == nil {
		s += msgp.NilSize
	} else {
		s += z.DexPriceAggregator.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RoundData) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "RoundId")
			return
		}
		z.RoundId = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.RoundId))
			if err != nil {
				err = msgp.WrapError(err, "RoundId")
				return
			}
			z.RoundId = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Answer")
			return
		}
		z.Answer = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.Answer))
			if err != nil {
				err = msgp.WrapError(err, "Answer")
				return
			}
			z.Answer = msgpencode.DecodeInt(zb0003)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "StartedAt")
			return
		}
		z.StartedAt = nil
	} else {
		{
			var zb0004 []byte
			zb0004, err = dc.ReadBytes(msgpencode.EncodeInt(z.StartedAt))
			if err != nil {
				err = msgp.WrapError(err, "StartedAt")
				return
			}
			z.StartedAt = msgpencode.DecodeInt(zb0004)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "UpdatedAt")
			return
		}
		z.UpdatedAt = nil
	} else {
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes(msgpencode.EncodeInt(z.UpdatedAt))
			if err != nil {
				err = msgp.WrapError(err, "UpdatedAt")
				return
			}
			z.UpdatedAt = msgpencode.DecodeInt(zb0005)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "AnsweredInRound")
			return
		}
		z.AnsweredInRound = nil
	} else {
		{
			var zb0006 []byte
			zb0006, err = dc.ReadBytes(msgpencode.EncodeInt(z.AnsweredInRound))
			if err != nil {
				err = msgp.WrapError(err, "AnsweredInRound")
				return
			}
			z.AnsweredInRound = msgpencode.DecodeInt(zb0006)
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RoundData) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 5
	err = en.Append(0x95)
	if err != nil {
		return
	}
	if z.RoundId == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.RoundId))
		if err != nil {
			err = msgp.WrapError(err, "RoundId")
			return
		}
	}
	if z.Answer == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Answer))
		if err != nil {
			err = msgp.WrapError(err, "Answer")
			return
		}
	}
	if z.StartedAt == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.StartedAt))
		if err != nil {
			err = msgp.WrapError(err, "StartedAt")
			return
		}
	}
	if z.UpdatedAt == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.UpdatedAt))
		if err != nil {
			err = msgp.WrapError(err, "UpdatedAt")
			return
		}
	}
	if z.AnsweredInRound == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.AnsweredInRound))
		if err != nil {
			err = msgp.WrapError(err, "AnsweredInRound")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RoundData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 5
	o = append(o, 0x95)
	if z.RoundId == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.RoundId))
	}
	if z.Answer == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Answer))
	}
	if z.StartedAt == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.StartedAt))
	}
	if z.UpdatedAt == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.UpdatedAt))
	}
	if z.AnsweredInRound == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.AnsweredInRound))
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RoundData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.RoundId = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.RoundId))
			if err != nil {
				err = msgp.WrapError(err, "RoundId")
				return
			}
			z.RoundId = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Answer = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Answer))
			if err != nil {
				err = msgp.WrapError(err, "Answer")
				return
			}
			z.Answer = msgpencode.DecodeInt(zb0003)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.StartedAt = nil
	} else {
		{
			var zb0004 []byte
			zb0004, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.StartedAt))
			if err != nil {
				err = msgp.WrapError(err, "StartedAt")
				return
			}
			z.StartedAt = msgpencode.DecodeInt(zb0004)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.UpdatedAt = nil
	} else {
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.UpdatedAt))
			if err != nil {
				err = msgp.WrapError(err, "UpdatedAt")
				return
			}
			z.UpdatedAt = msgpencode.DecodeInt(zb0005)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.AnsweredInRound = nil
	} else {
		{
			var zb0006 []byte
			zb0006, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.AnsweredInRound))
			if err != nil {
				err = msgp.WrapError(err, "AnsweredInRound")
				return
			}
			z.AnsweredInRound = msgpencode.DecodeInt(zb0006)
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RoundData) Msgsize() (s int) {
	s = 1
	if z.RoundId == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.RoundId))
	}
	if z.Answer == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Answer))
	}
	if z.StartedAt == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.StartedAt))
	}
	if z.UpdatedAt == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.UpdatedAt))
	}
	if z.AnsweredInRound == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.AnsweredInRound))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Slot0) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 7 {
		err = msgp.ArrayError{Wanted: 7, Got: zb0001}
		return
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "SqrtPriceX96")
			return
		}
		z.SqrtPriceX96 = nil
	} else {
		{
			var zb0002 []byte
			zb0002, err = dc.ReadBytes(msgpencode.EncodeInt(z.SqrtPriceX96))
			if err != nil {
				err = msgp.WrapError(err, "SqrtPriceX96")
				return
			}
			z.SqrtPriceX96 = msgpencode.DecodeInt(zb0002)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "Tick")
			return
		}
		z.Tick = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.Tick))
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
			z.Tick = msgpencode.DecodeInt(zb0003)
		}
	}
	z.ObservationIndex, err = dc.ReadUint16()
	if err != nil {
		err = msgp.WrapError(err, "ObservationIndex")
		return
	}
	z.ObservationCardinality, err = dc.ReadUint16()
	if err != nil {
		err = msgp.WrapError(err, "ObservationCardinality")
		return
	}
	z.ObservationCardinalityNext, err = dc.ReadUint16()
	if err != nil {
		err = msgp.WrapError(err, "ObservationCardinalityNext")
		return
	}
	z.FeeProtocol, err = dc.ReadUint8()
	if err != nil {
		err = msgp.WrapError(err, "FeeProtocol")
		return
	}
	z.Unlocked, err = dc.ReadBool()
	if err != nil {
		err = msgp.WrapError(err, "Unlocked")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Slot0) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 7
	err = en.Append(0x97)
	if err != nil {
		return
	}
	if z.SqrtPriceX96 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.SqrtPriceX96))
		if err != nil {
			err = msgp.WrapError(err, "SqrtPriceX96")
			return
		}
	}
	if z.Tick == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.Tick))
		if err != nil {
			err = msgp.WrapError(err, "Tick")
			return
		}
	}
	err = en.WriteUint16(z.ObservationIndex)
	if err != nil {
		err = msgp.WrapError(err, "ObservationIndex")
		return
	}
	err = en.WriteUint16(z.ObservationCardinality)
	if err != nil {
		err = msgp.WrapError(err, "ObservationCardinality")
		return
	}
	err = en.WriteUint16(z.ObservationCardinalityNext)
	if err != nil {
		err = msgp.WrapError(err, "ObservationCardinalityNext")
		return
	}
	err = en.WriteUint8(z.FeeProtocol)
	if err != nil {
		err = msgp.WrapError(err, "FeeProtocol")
		return
	}
	err = en.WriteBool(z.Unlocked)
	if err != nil {
		err = msgp.WrapError(err, "Unlocked")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Slot0) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 7
	o = append(o, 0x97)
	if z.SqrtPriceX96 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.SqrtPriceX96))
	}
	if z.Tick == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.Tick))
	}
	o = msgp.AppendUint16(o, z.ObservationIndex)
	o = msgp.AppendUint16(o, z.ObservationCardinality)
	o = msgp.AppendUint16(o, z.ObservationCardinalityNext)
	o = msgp.AppendUint8(o, z.FeeProtocol)
	o = msgp.AppendBool(o, z.Unlocked)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Slot0) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 7 {
		err = msgp.ArrayError{Wanted: 7, Got: zb0001}
		return
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.SqrtPriceX96 = nil
	} else {
		{
			var zb0002 []byte
			zb0002, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.SqrtPriceX96))
			if err != nil {
				err = msgp.WrapError(err, "SqrtPriceX96")
				return
			}
			z.SqrtPriceX96 = msgpencode.DecodeInt(zb0002)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.Tick = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.Tick))
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
			z.Tick = msgpencode.DecodeInt(zb0003)
		}
	}
	z.ObservationIndex, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "ObservationIndex")
		return
	}
	z.ObservationCardinality, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "ObservationCardinality")
		return
	}
	z.ObservationCardinalityNext, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "ObservationCardinalityNext")
		return
	}
	z.FeeProtocol, bts, err = msgp.ReadUint8Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "FeeProtocol")
		return
	}
	z.Unlocked, bts, err = msgp.ReadBoolBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Unlocked")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Slot0) Msgsize() (s int) {
	s = 1
	if z.SqrtPriceX96 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.SqrtPriceX96))
	}
	if z.Tick == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.Tick))
	}
	s += msgp.Uint16Size + msgp.Uint16Size + msgp.Uint16Size + msgp.Uint8Size + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SystemSettings) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 10 {
		err = msgp.ArrayError{Wanted: 10, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled")
		return
	}
	if z.PureChainlinkPriceForAtomicSwapsEnabled == nil {
		z.PureChainlinkPriceForAtomicSwapsEnabled = make(map[string]bool, zb0002)
	} else if len(z.PureChainlinkPriceForAtomicSwapsEnabled) > 0 {
		for key := range z.PureChainlinkPriceForAtomicSwapsEnabled {
			delete(z.PureChainlinkPriceForAtomicSwapsEnabled, key)
		}
	}
	for zb0002 > 0 {
		zb0002--
		var za0001 string
		var za0002 bool
		za0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled")
			return
		}
		za0002, err = dc.ReadBool()
		if err != nil {
			err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled", za0001)
			return
		}
		z.PureChainlinkPriceForAtomicSwapsEnabled[za0001] = za0002
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "AtomicTwapWindow")
			return
		}
		z.AtomicTwapWindow = nil
	} else {
		{
			var zb0003 []byte
			zb0003, err = dc.ReadBytes(msgpencode.EncodeInt(z.AtomicTwapWindow))
			if err != nil {
				err = msgp.WrapError(err, "AtomicTwapWindow")
				return
			}
			z.AtomicTwapWindow = msgpencode.DecodeInt(zb0003)
		}
	}
	var zb0004 uint32
	zb0004, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses")
		return
	}
	if z.AtomicEquivalentForDexPricingAddresses == nil {
		z.AtomicEquivalentForDexPricingAddresses = make(map[string]common.Address, zb0004)
	} else if len(z.AtomicEquivalentForDexPricingAddresses) > 0 {
		for key := range z.AtomicEquivalentForDexPricingAddresses {
			delete(z.AtomicEquivalentForDexPricingAddresses, key)
		}
	}
	for zb0004 > 0 {
		zb0004--
		var za0003 string
		var za0004 common.Address
		za0003, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses")
			return
		}
		{
			var zb0005 []byte
			zb0005, err = dc.ReadBytes((common.Address).Bytes(za0004))
			if err != nil {
				err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses", za0003)
				return
			}
			za0004 = common.BytesToAddress(zb0005)
		}
		z.AtomicEquivalentForDexPricingAddresses[za0003] = za0004
	}
	var zb0006 uint32
	zb0006, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "AtomicEquivalentForDexPricing")
		return
	}
	if z.AtomicEquivalentForDexPricing == nil {
		z.AtomicEquivalentForDexPricing = make(map[string]Token, zb0006)
	} else if len(z.AtomicEquivalentForDexPricing) > 0 {
		for key := range z.AtomicEquivalentForDexPricing {
			delete(z.AtomicEquivalentForDexPricing, key)
		}
	}
	for zb0006 > 0 {
		zb0006--
		var za0005 string
		var za0006 Token
		za0005, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing")
			return
		}
		var zb0007 uint32
		zb0007, err = dc.ReadArrayHeader()
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005)
			return
		}
		if zb0007 != 3 {
			err = msgp.ArrayError{Wanted: 3, Got: zb0007}
			return
		}
		{
			var zb0008 []byte
			zb0008, err = dc.ReadBytes((common.Address).Bytes(za0006.Address))
			if err != nil {
				err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Address")
				return
			}
			za0006.Address = common.BytesToAddress(zb0008)
		}
		za0006.Decimals, err = dc.ReadUint8()
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Decimals")
			return
		}
		za0006.Symbol, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Symbol")
			return
		}
		z.AtomicEquivalentForDexPricing[za0005] = za0006
	}
	var zb0009 uint32
	zb0009, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow")
		return
	}
	if z.AtomicVolatilityConsiderationWindow == nil {
		z.AtomicVolatilityConsiderationWindow = make(map[string]*big.Int, zb0009)
	} else if len(z.AtomicVolatilityConsiderationWindow) > 0 {
		for key := range z.AtomicVolatilityConsiderationWindow {
			delete(z.AtomicVolatilityConsiderationWindow, key)
		}
	}
	for zb0009 > 0 {
		zb0009--
		var za0007 string
		var za0008 *big.Int
		za0007, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow", za0007)
				return
			}
			za0008 = nil
		} else {
			{
				var zb0010 []byte
				zb0010, err = dc.ReadBytes(msgpencode.EncodeInt(za0008))
				if err != nil {
					err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow", za0007)
					return
				}
				za0008 = msgpencode.DecodeInt(zb0010)
			}
		}
		z.AtomicVolatilityConsiderationWindow[za0007] = za0008
	}
	var zb0011 uint32
	zb0011, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold")
		return
	}
	if z.AtomicVolatilityUpdateThreshold == nil {
		z.AtomicVolatilityUpdateThreshold = make(map[string]*big.Int, zb0011)
	} else if len(z.AtomicVolatilityUpdateThreshold) > 0 {
		for key := range z.AtomicVolatilityUpdateThreshold {
			delete(z.AtomicVolatilityUpdateThreshold, key)
		}
	}
	for zb0011 > 0 {
		zb0011--
		var za0009 string
		var za0010 *big.Int
		za0009, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold", za0009)
				return
			}
			za0010 = nil
		} else {
			{
				var zb0012 []byte
				zb0012, err = dc.ReadBytes(msgpencode.EncodeInt(za0010))
				if err != nil {
					err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold", za0009)
					return
				}
				za0010 = msgpencode.DecodeInt(zb0012)
			}
		}
		z.AtomicVolatilityUpdateThreshold[za0009] = za0010
	}
	var zb0013 uint32
	zb0013, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "AtomicExchangeFeeRate")
		return
	}
	if z.AtomicExchangeFeeRate == nil {
		z.AtomicExchangeFeeRate = make(map[string]*big.Int, zb0013)
	} else if len(z.AtomicExchangeFeeRate) > 0 {
		for key := range z.AtomicExchangeFeeRate {
			delete(z.AtomicExchangeFeeRate, key)
		}
	}
	for zb0013 > 0 {
		zb0013--
		var za0011 string
		var za0012 *big.Int
		za0011, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "AtomicExchangeFeeRate")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "AtomicExchangeFeeRate", za0011)
				return
			}
			za0012 = nil
		} else {
			{
				var zb0014 []byte
				zb0014, err = dc.ReadBytes(msgpencode.EncodeInt(za0012))
				if err != nil {
					err = msgp.WrapError(err, "AtomicExchangeFeeRate", za0011)
					return
				}
				za0012 = msgpencode.DecodeInt(zb0014)
			}
		}
		z.AtomicExchangeFeeRate[za0011] = za0012
	}
	var zb0015 uint32
	zb0015, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err, "ExchangeFeeRate")
		return
	}
	if z.ExchangeFeeRate == nil {
		z.ExchangeFeeRate = make(map[string]*big.Int, zb0015)
	} else if len(z.ExchangeFeeRate) > 0 {
		for key := range z.ExchangeFeeRate {
			delete(z.ExchangeFeeRate, key)
		}
	}
	for zb0015 > 0 {
		zb0015--
		var za0013 string
		var za0014 *big.Int
		za0013, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err, "ExchangeFeeRate")
			return
		}
		if dc.IsNil() {
			err = dc.ReadNil()
			if err != nil {
				err = msgp.WrapError(err, "ExchangeFeeRate", za0013)
				return
			}
			za0014 = nil
		} else {
			{
				var zb0016 []byte
				zb0016, err = dc.ReadBytes(msgpencode.EncodeInt(za0014))
				if err != nil {
					err = msgp.WrapError(err, "ExchangeFeeRate", za0013)
					return
				}
				za0014 = msgpencode.DecodeInt(zb0016)
			}
		}
		z.ExchangeFeeRate[za0013] = za0014
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "RateStalePeriod")
			return
		}
		z.RateStalePeriod = nil
	} else {
		{
			var zb0017 []byte
			zb0017, err = dc.ReadBytes(msgpencode.EncodeInt(z.RateStalePeriod))
			if err != nil {
				err = msgp.WrapError(err, "RateStalePeriod")
				return
			}
			z.RateStalePeriod = msgpencode.DecodeInt(zb0017)
		}
	}
	if dc.IsNil() {
		err = dc.ReadNil()
		if err != nil {
			err = msgp.WrapError(err, "DynamicFeeConfig")
			return
		}
		z.DynamicFeeConfig = nil
	} else {
		if z.DynamicFeeConfig == nil {
			z.DynamicFeeConfig = new(DynamicFeeConfig)
		}
		err = z.DynamicFeeConfig.DecodeMsg(dc)
		if err != nil {
			err = msgp.WrapError(err, "DynamicFeeConfig")
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SystemSettings) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 10
	err = en.Append(0x9a)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.PureChainlinkPriceForAtomicSwapsEnabled)))
	if err != nil {
		err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled")
		return
	}
	for za0001, za0002 := range z.PureChainlinkPriceForAtomicSwapsEnabled {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled")
			return
		}
		err = en.WriteBool(za0002)
		if err != nil {
			err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled", za0001)
			return
		}
	}
	if z.AtomicTwapWindow == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.AtomicTwapWindow))
		if err != nil {
			err = msgp.WrapError(err, "AtomicTwapWindow")
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.AtomicEquivalentForDexPricingAddresses)))
	if err != nil {
		err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses")
		return
	}
	for za0003, za0004 := range z.AtomicEquivalentForDexPricingAddresses {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses")
			return
		}
		err = en.WriteBytes((common.Address).Bytes(za0004))
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses", za0003)
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.AtomicEquivalentForDexPricing)))
	if err != nil {
		err = msgp.WrapError(err, "AtomicEquivalentForDexPricing")
		return
	}
	for za0005, za0006 := range z.AtomicEquivalentForDexPricing {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing")
			return
		}
		// array header, size 3
		err = en.Append(0x93)
		if err != nil {
			return
		}
		err = en.WriteBytes((common.Address).Bytes(za0006.Address))
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Address")
			return
		}
		err = en.WriteUint8(za0006.Decimals)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Decimals")
			return
		}
		err = en.WriteString(za0006.Symbol)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Symbol")
			return
		}
	}
	err = en.WriteMapHeader(uint32(len(z.AtomicVolatilityConsiderationWindow)))
	if err != nil {
		err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow")
		return
	}
	for za0007, za0008 := range z.AtomicVolatilityConsiderationWindow {
		err = en.WriteString(za0007)
		if err != nil {
			err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow")
			return
		}
		if za0008 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0008))
			if err != nil {
				err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow", za0007)
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.AtomicVolatilityUpdateThreshold)))
	if err != nil {
		err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold")
		return
	}
	for za0009, za0010 := range z.AtomicVolatilityUpdateThreshold {
		err = en.WriteString(za0009)
		if err != nil {
			err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold")
			return
		}
		if za0010 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0010))
			if err != nil {
				err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold", za0009)
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.AtomicExchangeFeeRate)))
	if err != nil {
		err = msgp.WrapError(err, "AtomicExchangeFeeRate")
		return
	}
	for za0011, za0012 := range z.AtomicExchangeFeeRate {
		err = en.WriteString(za0011)
		if err != nil {
			err = msgp.WrapError(err, "AtomicExchangeFeeRate")
			return
		}
		if za0012 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0012))
			if err != nil {
				err = msgp.WrapError(err, "AtomicExchangeFeeRate", za0011)
				return
			}
		}
	}
	err = en.WriteMapHeader(uint32(len(z.ExchangeFeeRate)))
	if err != nil {
		err = msgp.WrapError(err, "ExchangeFeeRate")
		return
	}
	for za0013, za0014 := range z.ExchangeFeeRate {
		err = en.WriteString(za0013)
		if err != nil {
			err = msgp.WrapError(err, "ExchangeFeeRate")
			return
		}
		if za0014 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBytes(msgpencode.EncodeInt(za0014))
			if err != nil {
				err = msgp.WrapError(err, "ExchangeFeeRate", za0013)
				return
			}
		}
	}
	if z.RateStalePeriod == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteBytes(msgpencode.EncodeInt(z.RateStalePeriod))
		if err != nil {
			err = msgp.WrapError(err, "RateStalePeriod")
			return
		}
	}
	if z.DynamicFeeConfig == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.DynamicFeeConfig.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "DynamicFeeConfig")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SystemSettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 10
	o = append(o, 0x9a)
	o = msgp.AppendMapHeader(o, uint32(len(z.PureChainlinkPriceForAtomicSwapsEnabled)))
	for za0001, za0002 := range z.PureChainlinkPriceForAtomicSwapsEnabled {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendBool(o, za0002)
	}
	if z.AtomicTwapWindow == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.AtomicTwapWindow))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.AtomicEquivalentForDexPricingAddresses)))
	for za0003, za0004 := range z.AtomicEquivalentForDexPricingAddresses {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendBytes(o, (common.Address).Bytes(za0004))
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.AtomicEquivalentForDexPricing)))
	for za0005, za0006 := range z.AtomicEquivalentForDexPricing {
		o = msgp.AppendString(o, za0005)
		// array header, size 3
		o = append(o, 0x93)
		o = msgp.AppendBytes(o, (common.Address).Bytes(za0006.Address))
		o = msgp.AppendUint8(o, za0006.Decimals)
		o = msgp.AppendString(o, za0006.Symbol)
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.AtomicVolatilityConsiderationWindow)))
	for za0007, za0008 := range z.AtomicVolatilityConsiderationWindow {
		o = msgp.AppendString(o, za0007)
		if za0008 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0008))
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.AtomicVolatilityUpdateThreshold)))
	for za0009, za0010 := range z.AtomicVolatilityUpdateThreshold {
		o = msgp.AppendString(o, za0009)
		if za0010 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0010))
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.AtomicExchangeFeeRate)))
	for za0011, za0012 := range z.AtomicExchangeFeeRate {
		o = msgp.AppendString(o, za0011)
		if za0012 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0012))
		}
	}
	o = msgp.AppendMapHeader(o, uint32(len(z.ExchangeFeeRate)))
	for za0013, za0014 := range z.ExchangeFeeRate {
		o = msgp.AppendString(o, za0013)
		if za0014 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBytes(o, msgpencode.EncodeInt(za0014))
		}
	}
	if z.RateStalePeriod == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendBytes(o, msgpencode.EncodeInt(z.RateStalePeriod))
	}
	if z.DynamicFeeConfig == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.DynamicFeeConfig.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "DynamicFeeConfig")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SystemSettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 10 {
		err = msgp.ArrayError{Wanted: 10, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled")
		return
	}
	if z.PureChainlinkPriceForAtomicSwapsEnabled == nil {
		z.PureChainlinkPriceForAtomicSwapsEnabled = make(map[string]bool, zb0002)
	} else if len(z.PureChainlinkPriceForAtomicSwapsEnabled) > 0 {
		for key := range z.PureChainlinkPriceForAtomicSwapsEnabled {
			delete(z.PureChainlinkPriceForAtomicSwapsEnabled, key)
		}
	}
	for zb0002 > 0 {
		var za0001 string
		var za0002 bool
		zb0002--
		za0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled")
			return
		}
		za0002, bts, err = msgp.ReadBoolBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "PureChainlinkPriceForAtomicSwapsEnabled", za0001)
			return
		}
		z.PureChainlinkPriceForAtomicSwapsEnabled[za0001] = za0002
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.AtomicTwapWindow = nil
	} else {
		{
			var zb0003 []byte
			zb0003, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.AtomicTwapWindow))
			if err != nil {
				err = msgp.WrapError(err, "AtomicTwapWindow")
				return
			}
			z.AtomicTwapWindow = msgpencode.DecodeInt(zb0003)
		}
	}
	var zb0004 uint32
	zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses")
		return
	}
	if z.AtomicEquivalentForDexPricingAddresses == nil {
		z.AtomicEquivalentForDexPricingAddresses = make(map[string]common.Address, zb0004)
	} else if len(z.AtomicEquivalentForDexPricingAddresses) > 0 {
		for key := range z.AtomicEquivalentForDexPricingAddresses {
			delete(z.AtomicEquivalentForDexPricingAddresses, key)
		}
	}
	for zb0004 > 0 {
		var za0003 string
		var za0004 common.Address
		zb0004--
		za0003, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses")
			return
		}
		{
			var zb0005 []byte
			zb0005, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(za0004))
			if err != nil {
				err = msgp.WrapError(err, "AtomicEquivalentForDexPricingAddresses", za0003)
				return
			}
			za0004 = common.BytesToAddress(zb0005)
		}
		z.AtomicEquivalentForDexPricingAddresses[za0003] = za0004
	}
	var zb0006 uint32
	zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AtomicEquivalentForDexPricing")
		return
	}
	if z.AtomicEquivalentForDexPricing == nil {
		z.AtomicEquivalentForDexPricing = make(map[string]Token, zb0006)
	} else if len(z.AtomicEquivalentForDexPricing) > 0 {
		for key := range z.AtomicEquivalentForDexPricing {
			delete(z.AtomicEquivalentForDexPricing, key)
		}
	}
	for zb0006 > 0 {
		var za0005 string
		var za0006 Token
		zb0006--
		za0005, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing")
			return
		}
		var zb0007 uint32
		zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005)
			return
		}
		if zb0007 != 3 {
			err = msgp.ArrayError{Wanted: 3, Got: zb0007}
			return
		}
		{
			var zb0008 []byte
			zb0008, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(za0006.Address))
			if err != nil {
				err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Address")
				return
			}
			za0006.Address = common.BytesToAddress(zb0008)
		}
		za0006.Decimals, bts, err = msgp.ReadUint8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Decimals")
			return
		}
		za0006.Symbol, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicEquivalentForDexPricing", za0005, "Symbol")
			return
		}
		z.AtomicEquivalentForDexPricing[za0005] = za0006
	}
	var zb0009 uint32
	zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow")
		return
	}
	if z.AtomicVolatilityConsiderationWindow == nil {
		z.AtomicVolatilityConsiderationWindow = make(map[string]*big.Int, zb0009)
	} else if len(z.AtomicVolatilityConsiderationWindow) > 0 {
		for key := range z.AtomicVolatilityConsiderationWindow {
			delete(z.AtomicVolatilityConsiderationWindow, key)
		}
	}
	for zb0009 > 0 {
		var za0007 string
		var za0008 *big.Int
		zb0009--
		za0007, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0008 = nil
		} else {
			{
				var zb0010 []byte
				zb0010, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0008))
				if err != nil {
					err = msgp.WrapError(err, "AtomicVolatilityConsiderationWindow", za0007)
					return
				}
				za0008 = msgpencode.DecodeInt(zb0010)
			}
		}
		z.AtomicVolatilityConsiderationWindow[za0007] = za0008
	}
	var zb0011 uint32
	zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold")
		return
	}
	if z.AtomicVolatilityUpdateThreshold == nil {
		z.AtomicVolatilityUpdateThreshold = make(map[string]*big.Int, zb0011)
	} else if len(z.AtomicVolatilityUpdateThreshold) > 0 {
		for key := range z.AtomicVolatilityUpdateThreshold {
			delete(z.AtomicVolatilityUpdateThreshold, key)
		}
	}
	for zb0011 > 0 {
		var za0009 string
		var za0010 *big.Int
		zb0011--
		za0009, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0010 = nil
		} else {
			{
				var zb0012 []byte
				zb0012, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0010))
				if err != nil {
					err = msgp.WrapError(err, "AtomicVolatilityUpdateThreshold", za0009)
					return
				}
				za0010 = msgpencode.DecodeInt(zb0012)
			}
		}
		z.AtomicVolatilityUpdateThreshold[za0009] = za0010
	}
	var zb0013 uint32
	zb0013, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "AtomicExchangeFeeRate")
		return
	}
	if z.AtomicExchangeFeeRate == nil {
		z.AtomicExchangeFeeRate = make(map[string]*big.Int, zb0013)
	} else if len(z.AtomicExchangeFeeRate) > 0 {
		for key := range z.AtomicExchangeFeeRate {
			delete(z.AtomicExchangeFeeRate, key)
		}
	}
	for zb0013 > 0 {
		var za0011 string
		var za0012 *big.Int
		zb0013--
		za0011, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "AtomicExchangeFeeRate")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0012 = nil
		} else {
			{
				var zb0014 []byte
				zb0014, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0012))
				if err != nil {
					err = msgp.WrapError(err, "AtomicExchangeFeeRate", za0011)
					return
				}
				za0012 = msgpencode.DecodeInt(zb0014)
			}
		}
		z.AtomicExchangeFeeRate[za0011] = za0012
	}
	var zb0015 uint32
	zb0015, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "ExchangeFeeRate")
		return
	}
	if z.ExchangeFeeRate == nil {
		z.ExchangeFeeRate = make(map[string]*big.Int, zb0015)
	} else if len(z.ExchangeFeeRate) > 0 {
		for key := range z.ExchangeFeeRate {
			delete(z.ExchangeFeeRate, key)
		}
	}
	for zb0015 > 0 {
		var za0013 string
		var za0014 *big.Int
		zb0015--
		za0013, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, "ExchangeFeeRate")
			return
		}
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			za0014 = nil
		} else {
			{
				var zb0016 []byte
				zb0016, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(za0014))
				if err != nil {
					err = msgp.WrapError(err, "ExchangeFeeRate", za0013)
					return
				}
				za0014 = msgpencode.DecodeInt(zb0016)
			}
		}
		z.ExchangeFeeRate[za0013] = za0014
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.RateStalePeriod = nil
	} else {
		{
			var zb0017 []byte
			zb0017, bts, err = msgp.ReadBytesBytes(bts, msgpencode.EncodeInt(z.RateStalePeriod))
			if err != nil {
				err = msgp.WrapError(err, "RateStalePeriod")
				return
			}
			z.RateStalePeriod = msgpencode.DecodeInt(zb0017)
		}
	}
	if msgp.IsNil(bts) {
		bts, err = msgp.ReadNilBytes(bts)
		if err != nil {
			return
		}
		z.DynamicFeeConfig = nil
	} else {
		if z.DynamicFeeConfig == nil {
			z.DynamicFeeConfig = new(DynamicFeeConfig)
		}
		bts, err = z.DynamicFeeConfig.UnmarshalMsg(bts)
		if err != nil {
			err = msgp.WrapError(err, "DynamicFeeConfig")
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SystemSettings) Msgsize() (s int) {
	s = 1 + msgp.MapHeaderSize
	if z.PureChainlinkPriceForAtomicSwapsEnabled != nil {
		for za0001, za0002 := range z.PureChainlinkPriceForAtomicSwapsEnabled {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.BoolSize
		}
	}
	if z.AtomicTwapWindow == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.AtomicTwapWindow))
	}
	s += msgp.MapHeaderSize
	if z.AtomicEquivalentForDexPricingAddresses != nil {
		for za0003, za0004 := range z.AtomicEquivalentForDexPricingAddresses {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.BytesPrefixSize + len((common.Address).Bytes(za0004))
		}
	}
	s += msgp.MapHeaderSize
	if z.AtomicEquivalentForDexPricing != nil {
		for za0005, za0006 := range z.AtomicEquivalentForDexPricing {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + 1 + msgp.BytesPrefixSize + len((common.Address).Bytes(za0006.Address)) + msgp.Uint8Size + msgp.StringPrefixSize + len(za0006.Symbol)
		}
	}
	s += msgp.MapHeaderSize
	if z.AtomicVolatilityConsiderationWindow != nil {
		for za0007, za0008 := range z.AtomicVolatilityConsiderationWindow {
			_ = za0008
			s += msgp.StringPrefixSize + len(za0007)
			if za0008 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0008))
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.AtomicVolatilityUpdateThreshold != nil {
		for za0009, za0010 := range z.AtomicVolatilityUpdateThreshold {
			_ = za0010
			s += msgp.StringPrefixSize + len(za0009)
			if za0010 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0010))
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.AtomicExchangeFeeRate != nil {
		for za0011, za0012 := range z.AtomicExchangeFeeRate {
			_ = za0012
			s += msgp.StringPrefixSize + len(za0011)
			if za0012 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0012))
			}
		}
	}
	s += msgp.MapHeaderSize
	if z.ExchangeFeeRate != nil {
		for za0013, za0014 := range z.ExchangeFeeRate {
			_ = za0014
			s += msgp.StringPrefixSize + len(za0013)
			if za0014 == nil {
				s += msgp.NilSize
			} else {
				s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(za0014))
			}
		}
	}
	if z.RateStalePeriod == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BytesPrefixSize + len(msgpencode.EncodeInt(z.RateStalePeriod))
	}
	if z.DynamicFeeConfig == nil {
		s += msgp.NilSize
	} else {
		s += z.DynamicFeeConfig.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Token) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	{
		var zb0002 []byte
		zb0002, err = dc.ReadBytes((common.Address).Bytes(z.Address))
		if err != nil {
			err = msgp.WrapError(err, "Address")
			return
		}
		z.Address = common.BytesToAddress(zb0002)
	}
	z.Decimals, err = dc.ReadUint8()
	if err != nil {
		err = msgp.WrapError(err, "Decimals")
		return
	}
	z.Symbol, err = dc.ReadString()
	if err != nil {
		err = msgp.WrapError(err, "Symbol")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Token) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes((common.Address).Bytes(z.Address))
	if err != nil {
		err = msgp.WrapError(err, "Address")
		return
	}
	err = en.WriteUint8(z.Decimals)
	if err != nil {
		err = msgp.WrapError(err, "Decimals")
		return
	}
	err = en.WriteString(z.Symbol)
	if err != nil {
		err = msgp.WrapError(err, "Symbol")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Token) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, (common.Address).Bytes(z.Address))
	o = msgp.AppendUint8(o, z.Decimals)
	o = msgp.AppendString(o, z.Symbol)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Token) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	{
		var zb0002 []byte
		zb0002, bts, err = msgp.ReadBytesBytes(bts, (common.Address).Bytes(z.Address))
		if err != nil {
			err = msgp.WrapError(err, "Address")
			return
		}
		z.Address = common.BytesToAddress(zb0002)
	}
	z.Decimals, bts, err = msgp.ReadUint8Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Decimals")
		return
	}
	z.Symbol, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Symbol")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Token) Msgsize() (s int) {
	s = 1 + msgp.BytesPrefixSize + len((common.Address).Bytes(z.Address)) + msgp.Uint8Size + msgp.StringPrefixSize + len(z.Symbol)
	return
}

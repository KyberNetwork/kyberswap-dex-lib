package main

import (
	"bufio"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

const (
	poolSimFileName    = "pool_simulator.go"
	pkgName            = "github.com/KyberNetwork/kyberswap-dex-lib"
	regularPoolSimName = "PoolSimulator"
)

var (
	irregularPoolSimNameByDexName = map[string]string{
		"pkg_source_balancer_stable":   "StablePool",
		"pkg_source_balancer_weighted": "WeightedPool2Tokens",
		"pkg_source_curve_aave":        "AavePool",
		"pkg_source_curve_base":        "PoolBaseSimulator",
		"pkg_source_curve_compound":    "CompoundPool",
		"pkg_source_curve_meta":        "Pool",
		"pkg_source_curve_plainoracle": "Pool",
		"pkg_source_curve_tricrypto":   "Pool",
		"pkg_source_curve_two":         "Pool",
		"pkg_source_maverickv1":        "Pool",
		"pkg_source_velocimeter":       "Pool",
	}
)

func main() {
	var paths []string

	if dir := findGoModDirInParents(); dir != "" {
		for _, path := range findAllPoolSimulatorSourceFile(dir) {
			path = strings.TrimPrefix(path, dir+"/")
			paths = append(paths, path)
		}
	}

	if len(paths) == 0 {
		return
	}

	dexNames := getImportNamesFromSourceFiles(paths)
	importPaths := getImportPathsFromSourceFiles(paths)

	outFile, err := os.Create("./dispatch_gen.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "could not create dispatch_gen.go: %s", err)
		panic(err)
	}
	defer outFile.Close()

	outFileBuf := bufio.NewWriter(outFile)
	defer outFileBuf.Flush()

	fmt.Fprintf(outFileBuf, "package poolsimulatormsgp\n")
	fmt.Fprintf(outFileBuf, "\n")

	fmt.Fprintf(outFileBuf, "// Code generated by %s/pkg/msgpencode/poolsimulatormsgp/cmd/generate DO NOT EDIT.\n", pkgName)
	fmt.Fprintf(outFileBuf, "\n")

	fmt.Fprintf(outFileBuf, "import (\n")
	for i, dexName := range dexNames {
		fmt.Fprintf(outFileBuf, "\t%s \"%s\"\n", dexName, importPaths[i])
	}
	fmt.Fprintf(outFileBuf, "\n")
	fmt.Fprintf(outFileBuf, "\t\"github.com/KyberNetwork/kyberswap-dex-lib/pkg/source/pool\"\n")
	fmt.Fprintf(outFileBuf, "\t\"github.com/tinylib/msgp/msgp\"\n")
	fmt.Fprintf(outFileBuf, ")\n")
	fmt.Fprintf(outFileBuf, "\n")

	fmt.Fprintf(outFileBuf, "func dispatchPoolSimulator(sim pool.IPoolSimulator) (dexName string, encodable msgp.Encodable) {\n")
	fmt.Fprintf(outFileBuf, "\tswitch sim := sim.(type) {\n")
	for _, dexName := range dexNames {
		poolSimName := regularPoolSimName
		if name, ok := irregularPoolSimNameByDexName[dexName]; ok {
			poolSimName = name
		}
		fmt.Fprintf(outFileBuf, "\tcase *%s.%s:\n", dexName, poolSimName)
		fmt.Fprintf(outFileBuf, "\t\tdexName = \"%s\"\n", dexName)
		fmt.Fprintf(outFileBuf, "\t\tencodable = sim\n")
	}
	fmt.Fprintf(outFileBuf, "\t}\n")
	fmt.Fprintf(outFileBuf, "\treturn\n")
	fmt.Fprintf(outFileBuf, "}\n")

	fmt.Fprintf(outFileBuf, "\n")
	fmt.Fprintf(outFileBuf, "func undispatchPoolSimulator(dexName string) (sim pool.IPoolSimulator, decodable msgp.Decodable) {\n")
	fmt.Fprintf(outFileBuf, "\tswitch dexName {\n")
	for _, dexName := range dexNames {
		poolSimName := regularPoolSimName
		if name, ok := irregularPoolSimNameByDexName[dexName]; ok {
			poolSimName = name
		}
		fmt.Fprintf(outFileBuf, "\tcase \"%s\":\n", dexName)
		fmt.Fprintf(outFileBuf, "\t\tpool := new(%s.%s)\n", dexName, poolSimName)
		fmt.Fprintf(outFileBuf, "\t\tsim = pool\n")
		fmt.Fprintf(outFileBuf, "\t\tdecodable = pool\n")
	}
	fmt.Fprintf(outFileBuf, "\t}\n")
	fmt.Fprintf(outFileBuf, "\treturn\n")
	fmt.Fprintf(outFileBuf, "}\n")
}

func findGoModDirInParents() string {
	var (
		hasGoMod = false
		cwd, _   = os.Getwd()
		visited  = make(map[string]struct{}) // to eliminate cycle
	)
	for {
		if _, ok := visited[cwd]; ok {
			break
		}
		visited[cwd] = struct{}{}

		entries, err := os.ReadDir(cwd)
		if err != nil {
			break
		}
		for _, entry := range entries {
			if entry.Name() == "go.mod" {
				hasGoMod = true
				break
			}
		}
		if hasGoMod {
			break
		}

		cwd = filepath.Join(cwd, "..")
		cwd, err = filepath.Abs(cwd)
		if err != nil {
			break
		}
	}
	if hasGoMod {
		return cwd
	}
	return ""
}

func findAllPoolSimulatorSourceFile(rootDir string) []string {
	var paths []string
	err := filepath.Walk(rootDir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if strings.HasSuffix(path, "/"+poolSimFileName) {
			paths = append(paths, path)
		}
		return nil
	})
	if err != nil {
		panic(err)
	}
	return paths
}

func getImportNamesFromSourceFiles(sourcePaths []string) []string {
	importNames := make([]string, 0, len(sourcePaths))
	for _, path := range sourcePaths {
		dexName := strings.TrimSuffix(path, "/"+poolSimFileName)
		dexName = strings.ReplaceAll(dexName, "-", "")
		dexName = strings.ReplaceAll(dexName, "/", "_")
		importNames = append(importNames, dexName)
	}
	return importNames
}

func getImportPathsFromSourceFiles(sourcePaths []string) []string {
	paths := make([]string, 0, len(sourcePaths))
	for _, path := range sourcePaths {
		importPath := filepath.Join(pkgName, strings.TrimSuffix(path, "/"+poolSimFileName))
		paths = append(paths, importPath)
	}
	return paths
}

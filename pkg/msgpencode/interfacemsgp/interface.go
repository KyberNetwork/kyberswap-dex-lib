package interfacemsgp

import (
	"fmt"
	"reflect"
	"sync"

	"github.com/KyberNetwork/logger"
	"github.com/tinylib/msgp/msgp"
)

type (
	concreteTypeReprT  string
	interfaceTypeReprT string
)

// EncoderHelper helps encode/decode and marshal/unmarshal interface I using tinylib/msgp.
// We must register a concrete type of interface I via [RegisterType] method before encoding it.
type EncoderHelper[I any] struct {
	// Mapping from string representation of a I's concrete type to the concrete type itself.
	// The string representation is used as type discriminator when encoding/decoding I.
	typeMap sync.Map // map[concreteTypeReprT]reflect.Type
	// string repr of I, for returning errors
	interfaceTypeRepr interfaceTypeReprT
}

// NewEncoderHelper ...
func NewEncoderHelper[I any]() *EncoderHelper[I] {
	return &EncoderHelper[I]{
		interfaceTypeRepr: interfaceTypeReprT(reflect.TypeFor[I]().Name()),
	}
}

// RegisterType registers the concrete types of an I. This method should be called in init() function.
func (h *EncoderHelper[I]) RegisterType(src I) error {
	// TODO: These checks only pass after encoding codes are generated by tinylib/msgp.
	// We disable these checks for now. We'll re-enable these checks after committing generated codes.
	if false {
		if _, ok := any(src).(msgp.Encodable); !ok {
			return fmt.Errorf("expected %s's concrete type to implement msgp.Encodable", h.interfaceTypeRepr)
		}
		if _, ok := any(src).(msgp.Decodable); !ok {
			return fmt.Errorf("expected %s's concrete type to implement msgp.Decodable", h.interfaceTypeRepr)
		}
		if _, ok := any(src).(msgp.Marshaler); !ok {
			return fmt.Errorf("expected %s's concrete type to implement msgp.Marshaler", h.interfaceTypeRepr)
		}
		if _, ok := any(src).(msgp.Unmarshaler); !ok {
			return fmt.Errorf("expected %s's concrete type to implement msgp.Unmarshaler", h.interfaceTypeRepr)
		}
		if _, ok := any(src).(msgp.Sizer); !ok {
			return fmt.Errorf("expected %s's concrete type to implement msgp.Sizer", h.interfaceTypeRepr)
		}
	}
	concreteType := reflect.ValueOf(src).Elem().Type()
	concreteTypeRepr := concreteTypeReprT(concreteType.String())

	if _, exist := h.typeMap.LoadOrStore(concreteTypeRepr, concreteType); exist {
		return fmt.Errorf("collided %s's concrete type %s", h.interfaceTypeRepr, concreteTypeRepr)
	}
	logger.Infof("registered type %s for interface %s\n", concreteTypeRepr, h.interfaceTypeRepr)
	return nil
}

// EncodeMsg is helper method for implementing msgp.Encodable
func (h *EncoderHelper[I]) EncodeMsg(src I, en *msgp.Writer) (err error) {
	concreteType := reflect.ValueOf(src).Elem().Type()
	concreteTypeRepr := concreteTypeReprT(concreteType.String())

	err = en.WriteString(string(concreteTypeRepr))
	if err != nil {
		return
	}

	if _, ok := h.typeMap.Load(concreteTypeRepr); !ok {
		err = fmt.Errorf("unregistered type %s", concreteTypeRepr)
		return
	}

	err = any(src).(msgp.Encodable).EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, h.interfaceTypeRepr)
		return
	}

	return
}

// DecodeMsg is helper method for implementing msgp.Decodable
func (h *EncoderHelper[I]) DecodeMsg(dc *msgp.Reader) (dst I, err error) {
	var concreteTypeStr string
	concreteTypeStr, err = dc.ReadString()
	if err != nil {
		return
	}

	concreteTypeRepr := concreteTypeReprT(concreteTypeStr)

	concreteType, ok := h.typeMap.Load(concreteTypeRepr)
	if !ok {
		err = fmt.Errorf("unregistered type %s", concreteTypeRepr)
		return
	}

	val := reflect.New(concreteType.(reflect.Type))
	err = val.Interface().(msgp.Decodable).DecodeMsg(dc)
	if err != nil {
		err = msgp.WrapError(err, h.interfaceTypeRepr)
		return
	}
	return val.Interface().(I), err
}

// MarshalMsg is helper method for implementing msgp.Marshaler
func (h *EncoderHelper[I]) MarshalMsg(src I, b []byte) (o []byte, err error) {
	o = msgp.Require(b, any(src).(msgp.Sizer).Msgsize())
	concreteType := reflect.ValueOf(src).Elem().Type()
	concreteTypeRepr := concreteTypeReprT(concreteType.String())
	o = msgp.AppendString(o, string(concreteTypeRepr))

	if _, ok := h.typeMap.Load(concreteTypeRepr); !ok {
		err = fmt.Errorf("unregistered type %s", concreteTypeRepr)
		return
	}

	o, err = any(src).(msgp.Marshaler).MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, h.interfaceTypeRepr)
		return
	}
	return
}

// UnmarshalMsg is helper method for implementing msgp.Unmarshaler
func (h *EncoderHelper[I]) UnmarshalMsg(bts []byte) (dst I, o []byte, err error) {
	var concreteTypeStr string
	concreteTypeStr, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		return
	}

	concreteTypeRepr := concreteTypeReprT(concreteTypeStr)

	concreteType, ok := h.typeMap.Load(concreteTypeRepr)
	if !ok {
		err = fmt.Errorf("unregistered type %s", concreteTypeRepr)
		return
	}

	val := reflect.New(concreteType.(reflect.Type))
	bts, err = val.Interface().(msgp.Unmarshaler).UnmarshalMsg(bts)
	if err != nil {
		err = msgp.WrapError(err, h.interfaceTypeRepr)
		return
	}

	o = bts
	return val.Interface().(I), o, err
}

// Msgsize is helper method for implementing msgp.Sizer
func (h *EncoderHelper[I]) Msgsize(src I) int {
	typ := reflect.ValueOf(src).Elem().Type()
	return msgp.StringPrefixSize + len(typ.String()) + any(src).(msgp.Sizer).Msgsize()
}

package swapdata

import (
	"encoding/hex"
	"fmt"
	"math/big"
	"testing"

	"github.com/KyberNetwork/router-service/internal/pkg/usecase/encode/l2encode/pack"
	"github.com/KyberNetwork/router-service/internal/pkg/usecase/types"
	"github.com/KyberNetwork/router-service/internal/pkg/utils"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/assert"
)

var packLimitOrderDSSwapPairs = []struct {
	data       KyberLimitOrderDS
	packedData string
}{
	{
		data: KyberLimitOrderDS{
			KyberLOAddress: common.HexToAddress("0x973B1847407C579a58E610e5f12003996C5a4f16"),
			MakerAsset:     common.HexToAddress("0x1a30c9ed6436e03d506227a362b2cbf59a303967"),
			Params: FillBatchOrdersParamsDS{
				Orders: []OrderDS{
					{
						Salt:           parseBigInt("135786982651412687203851465093295409688"),
						MakerAsset:     common.HexToAddress("0x1a30c9ed6436e03d506227a362b2cbf59a303967"),
						TakerAsset:     common.HexToAddress("0x4f6519025e6de0edb6e4901827c1956ce18c39d3"),
						Maker:          common.HexToAddress("0xef09879057a9ad798438f3ba561bcdd293d72fc7"),
						Receiver:       common.HexToAddress("0xef09879057a9ad798438f3ba561bcdd293d72fc7"),
						AllowedSender:  common.HexToAddress("0x0000000000000000000000000000000000000000"),
						TakingAmount:   big.NewInt(60000000000),
						MakingAmount:   big.NewInt(60000000000),
						FeeConfig:      pack.UInt200(utils.NewBig("146159165624476364475945418325124367680971254365544")),
						MakerAssetData: []byte("a"),
						TakerAssetData: []byte("b"),
						GetMakerAmount: []byte("f4a215c3000000000000000000000000000000000000000000000001d7d843dc3b4800000000000000000000000000000000000000000000000000000de0b6b3a7640000"),
						GetTakerAmount: []byte("296637bf000000000000000000000000000000000000000000000001d7d843dc3b4800000000000000000000000000000000000000000000000000000de0b6b3a7640000"),
						Predicate:      []byte("961d5b1e000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000002892e28b58ab329741f27fd1ea56dca0192a38840000000000000000000000002892e28b58ab329741f27fd1ea56dca0192a38840000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000044cf6fc6e3000000000000000000000000a246ec8bf7f2e54cc2f7bfdd869302ae4a08a590000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002463592c2b0000000000000000000000000000000000000000000000000000000063c1169800000000000000000000000000000000000000000000000000000000"),
						Interaction:    []byte(""),
					},
				},
				Signatures: []Signature{
					{
						OrderSignature: common.Hex2Bytes("564111ada586b6be45c406a0b6f4c1c0dfd2663c612ba280ca9a5944de69644b575c518d5618a66b0dfd1b1b10607c033dc6006ae38c7a4dc4fe9c5d1bec75481b"),
						OpSignature:    common.Hex2Bytes("b0b4a1d79dac9af74c46f25e657d88b1c435876164b7b070ab10ab32fbb2755e11fc1e78c166f60da7df485d4c9a3de897262ba8a9180466327d4d9a347097621c"),
					},
				},
				OpExpireTimes:   []uint32{1694656567},
				TakingAmount:    big.NewInt(60000),
				ThresholdAmount: new(big.Int).Sub(big.NewInt(1), big.NewInt(1)), // to get around assert unpack
				Target:          [20]byte{},
			},

			isFirstSwap: true,
		},
		packedData: "000000973b1847407c579a58e610e5f12003996c5a4f161a30c9ed6436e03d506227a362b2cbf59a3039670166279f20d372e378a056297a78308a181a30c9ed6436e03d506227a362b2cbf59a3039674f6519025e6de0edb6e4901827c1956ce18c39d3ef09879057a9ad798438f3ba561bcdd293d72fc7ef09879057a9ad798438f3ba561bcdd293d72fc7000000000000000000000000000000000000000000000000000000000000000df847580000000000000000000000000df847580000000000640193a8a52d77e27bdd4f12e0cdd52d8ff1d97d680000000161000000016200000088663461323135633330303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303164376438343364633362343830303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030306465306236623361373634303030300000008832393636333762663030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030316437643834336463336234383030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030646530623662336137363430303030000003c83936316435623165303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303034303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030613030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303032303030303030303030303030303030303030303030303030323839326532386235386162333239373431663237666431656135366463613031393261333838343030303030303030303030303030303030303030303030303238393265323862353861623332393734316632376664316561353664636130313932613338383430303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303032303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303034303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030633030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303434636636666336653330303030303030303030303030303030303030303030303061323436656338626637663265353463633266376266646438363933303261653461303861353930303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030363030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303032343633353932633262303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303036336331313639383030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030000000000100000041564111ada586b6be45c406a0b6f4c1c0dfd2663c612ba280ca9a5944de69644b575c518d5618a66b0dfd1b1b10607c033dc6006ae38c7a4dc4fe9c5d1bec75481b00000041b0b4a1d79dac9af74c46f25e657d88b1c435876164b7b070ab10ab32fbb2755e11fc1e78c166f60da7df485d4c9a3de897262ba8a9180466327d4d9a347097621c01650268370000000000000000000000000000ea60000000000000000000000000000000000000000000000000000000000000000000000000",
	},
}

func Test_packLimitOrderDS(t *testing.T) {
	t.Parallel()

	for idx, pair := range packLimitOrderDSSwapPairs {
		t.Run(fmt.Sprintf("it should pack correctly %d", idx), func(t *testing.T) {
			result, err := packKyberLimitOrderDS(pair.data)
			assert.ErrorIs(t, err, nil)
			assert.Equal(t, pair.packedData, hex.EncodeToString(result))
		})
	}
}

func TestUnpackLimitOrderDS(t *testing.T) {
	t.Parallel()

	for idx, pair := range packLimitOrderDSSwapPairs {
		t.Run(fmt.Sprintf("it should decode correctly %d", idx), func(t *testing.T) {
			result, err := UnpackKyberLimitOrderDS(
				common.Hex2Bytes(pair.packedData),
				pair.data.isFirstSwap,
			)

			assert.ErrorIs(t, err, nil)
			assert.EqualValues(t, pair.data, result)
		})
	}
}

func TestPackKyberLimitOrderDS(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		name         string
		encodingSwap types.L2EncodingSwap
		assert       func(t *testing.T, actualResult []byte, actualErr error)
	}{
		{
			name: "1. PoolExtra is nil",
			encodingSwap: types.L2EncodingSwap{
				EncodingSwap: types.EncodingSwap{
					Pool: "limit-order",
				},
			},
			assert: func(t *testing.T, actualResult []byte, actualErr error) {
				assert.Equal(t, []uint8([]byte(nil)), actualResult)
				assert.EqualError(t, actualErr, "[PackKyberLimitOrderDS] PoolExtra is nil")
			},
		},
		{
			name: "2. PoolExtra is not string",
			encodingSwap: types.L2EncodingSwap{
				EncodingSwap: types.EncodingSwap{
					Pool:      "limit-order",
					PoolExtra: 1,
				},
			},
			assert: func(t *testing.T, actualResult []byte, actualErr error) {
				assert.Equal(t, []uint8([]byte(nil)), actualResult)
				assert.EqualError(t, actualErr, "[PackKyberLimitOrderDS] Invalid LO contract address: 1, pool: limit-order")
			},
		},
		{
			name: "3. PoolExtra is not an address",
			encodingSwap: types.L2EncodingSwap{
				EncodingSwap: types.EncodingSwap{
					Pool:      "limit-order",
					PoolExtra: "0x00",
				},
			},
			assert: func(t *testing.T, actualResult []byte, actualErr error) {
				assert.Equal(t, []uint8([]byte(nil)), actualResult)
				assert.EqualError(t, actualErr, "[PackKyberLimitOrderDS] Invalid LO contract address: 0x00, pool: limit-order")
			},
		},
		{
			name: "4. Get contract address successfully",
			encodingSwap: types.L2EncodingSwap{
				EncodingSwap: types.EncodingSwap{
					Pool:      "limit-order",
					PoolExtra: "0xef09879057a9ad798438f3ba561bcdd293d72fc7",
					Extra: map[string]interface{}{
						"amountIn": "60000000000",
						"filledOrders": []map[string]interface{}{
							{
								"orderID":              1,
								"salt":                 "135786982651412687203851465093295409688",
								"makerAsset":           "0x1a30c9ed6436e03d506227a362b2cbf59a303967",
								"takerAsset":           "0x4f6519025e6de0edb6e4901827c1956ce18c39d3",
								"maker":                "0xef09879057a9ad798438f3ba561bcdd293d72fc7",
								"receiver":             "0xef09879057a9ad798438f3ba561bcdd293d72fc7",
								"takingAmount":         "60000000000",
								"makingAmount":         "60000000000",
								"feeRecipient":         "0x0000000000000000000000000000000000000000",
								"makerTokenFeePercent": 22,
								"feeConfig":            "146159165624476364475945418325124367680971254365544",
							},
						},
						"operatorSignaturesById": map[int64]interface{}{
							1: map[string]interface{}{
								"id":                         1,
								"chainId":                    "1",
								"operatorSignature":          "b0b4a1d79dac9af74c46f25e657d88b1c435876164b7b070ab10ab32fbb2755e11fc1e78c166f60da7df485d4c9a3de897262ba8a9180466327d4d9a347097621c",
								"operatorSignatureExpiredAt": 1694656567,
							},
						},
					},
				},
			},
			assert: func(t *testing.T, actualResult []byte, actualErr error) {
				assert.NotNil(t, actualResult)
				assert.NoError(t, actualErr)
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result, err := PackKyberLimitOrderDS(1, tc.encodingSwap)
			tc.assert(t, result, err)
		})
	}
}

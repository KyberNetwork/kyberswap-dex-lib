package executor

import (
	"fmt"
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/assert"

	"github.com/KyberNetwork/router-service/internal/pkg/constant"
	"github.com/KyberNetwork/router-service/internal/pkg/usecase/types"
	"github.com/KyberNetwork/router-service/internal/pkg/valueobject"
)

func TestBuildAndPackSimpleSwapData(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		name           string
		chainID        valueobject.ChainID
		routerAddress  string
		data           types.EncodingData
		expectedResult string
		expectedError  error
	}{
		{
			name:          "it should build and pack simpleSwapData correctly",
			chainID:       valueobject.ChainIDPolygon,
			routerAddress: "0xa66cc4b4c17361532f0baba708941b7b8cdf7aa0",
			data: types.EncodingData{
				TokenIn:           "0xa66cc4b4c17361532f0baba708941b7b8cdf7aa0",
				TokenOut:          "0x2771a9fdbaf7d37679116191007c4829cf7616d2",
				Deadline:          big.NewInt(10000),
				SlippageTolerance: big.NewInt(2000),
				InputAmount:       big.NewInt(1000),
				OutputAmount:      big.NewInt(1000),
				TotalAmountOut:    big.NewInt(1000),
				Recipient:         "0xa66cc4b4c17361532f0baba708941b7b8cdf7aa0",
				Route: [][]types.EncodingSwap{
					{
						{
							Pool:              "0xa66cc4b4c17361532f0baba708941b7b8cdf7aa0",
							TokenIn:           "0xa66cc4b4c17361532f0baba708941b7b8cdf7aa0",
							TokenOut:          "0x2771a9fdbaf7d37679116191007c4829cf7616d2",
							SwapAmount:        big.NewInt(100000),
							AmountOut:         big.NewInt(100000),
							LimitReturnAmount: big.NewInt(1),
							PoolLength:        1,
							PoolType:          constant.PoolTypes.Uni,
							Exchange:          valueobject.ExchangeUniSwap,
							CollectAmount:     types.ZeroCollectAmount,
							Recipient:         "0xa66cc4b4c17361532f0baba708941b7b8cdf7aa0",
						},
					},
				},
			},
			expectedResult: "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a66cc4b4c17361532f0baba708941b7b8cdf7aa0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004059361199000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000a66cc4b4c17361532f0baba708941b7b8cdf7aa0000000000000000000000000a66cc4b4c17361532f0baba708941b7b8cdf7aa00000000000000000000000002771a9fdbaf7d37679116191007c4829cf7616d2000000000000000000000000a66cc4b4c17361532f0baba708941b7b8cdf7aa00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000027100000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000003e8",
			expectedError:  nil,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result, err := BuildAndPackSimpleSwapData(tc.chainID, tc.routerAddress, true, tc.data)

			assert.Equal(t, tc.expectedResult, common.Bytes2Hex(result))
			assert.ErrorIs(t, err, tc.expectedError)
		})
	}
}

var packSimpleSwapDataPairs = []struct {
	data       SimpleSwapData
	packedData string
}{
	{
		data: SimpleSwapData{
			FirstPools:       []common.Address{},
			FirstSwapAmounts: []*big.Int{},
			SwapDatas: [][]byte{
				[]byte("swap1"),
				[]byte("swap2"),
			},
			Deadline:         big.NewInt(10000),
			DestTokenFeeData: []byte("destTokenFeeData"),
		},
		packedData: "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000005737761703100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000057377617032000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001064657374546f6b656e4665654461746100000000000000000000000000000000",
	},
}

func TestPackSimpleSwapData(t *testing.T) {
	t.Parallel()

	for idx, pair := range packSimpleSwapDataPairs {
		t.Run(fmt.Sprintf("it should encode correctly %d", idx), func(t *testing.T) {
			result, err := PackSimpleSwapData(pair.data)

			assert.Nil(t, err)
			assert.Equal(t, pair.packedData, common.Bytes2Hex(result))
		})
	}
}

func TestUnpackSimpleSwapData(t *testing.T) {
	for idx, pair := range packSimpleSwapDataPairs {
		t.Run(fmt.Sprintf("it should decode correctly %d", idx), func(t *testing.T) {
			result, err := UnpackSimpleSwapData(common.Hex2Bytes(pair.packedData))

			assert.Nil(t, err)
			assert.Equal(t, pair.data, result)
		})
	}
}
